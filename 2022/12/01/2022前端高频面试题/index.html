



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Mondy" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Mondy" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="Mondy" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://example.com/2022/12/01/2022%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/">



  <title>
2022前端高频面试题 |
Mondy</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">2022前端高频面试题
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2022-12-01 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2022-12-01T00:00:00+08:00">2022-12-01</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>40k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>37 分钟</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Mondy</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipev1x5e4j20zk0m8b29.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclgi503lj20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeu1usa7j20zk0m8b29.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/01/2022%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="zhixiong">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Mondy">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><code>beforeCreate</code>  <code>created</code>  <code>beforMount</code> <code>mounted</code> <img data-src="C:\Users\m1769\AppData\Roaming\Typora\typora-user-images\image-20220911193849106.png" alt="image-20220911193849106"></p>
<p><img data-src="C:\Users\m1769\AppData\Roaming\Typora\typora-user-images\image-20220911193920139.png" alt="image-20220911193920139"></p>
<h2 id="GET请求和POST请求的区别是什么"><a href="#GET请求和POST请求的区别是什么" class="headerlink" title="GET请求和POST请求的区别是什么"></a>GET请求和POST请求的区别是什么</h2><p>GET请求参数是通过URL进行传递的，POST请求的参数包含在请求体当中。</p>
<p>GET请求比POST请求更不安全，因为参数直接暴露在URL中，所以，GET请求不能用来传递敏感信息。</p>
<p>GET请求在url中传递的参数是有长度限制的(在HTTP协议中并没有对URL的长度进行限制，限制是特定的浏览器以及服务器对他的限制，不同浏览器限制的长度不同。)，POST对长度没有限制。</p>
<p>GET请求参数会完整的保留在浏览器的历史记录中，POST请求的参数不会保留。</p>
<p>GET请求进行url编码(百分号编码)，POST请求支持多种编码方式。</p>
<p>GET请求产生的URL地址是可以被bookmark(添加书签)的，POST请求不可以。</p>
<p>GET请求在浏览器回退的时候是无害的，POST请求会.再次提交数据。</p>
<p>GET请求在浏览器中可以被主动cache(缓存)，而POST请求不会,可以手动设置。</p>
<h3 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h3><ul>
<li>于GET请求，浏览器会把http header和data一起发送出去，服务器响应200，请求成功。</li>
<li>对于POST请求，浏览器先发送header，服务器会响应100（已经收到请求的第一部分，正在等待其余部分），浏览器再次发送data，服务器返回200，请求成功。</li>
</ul>
<h2 id="移动端缩放的延迟？"><a href="#移动端缩放的延迟？" class="headerlink" title="移动端缩放的延迟？"></a>移动端缩放的延迟？</h2><p>  移动浏览器为什么会设置300毫秒的等待时间呢？这与双击缩放的方案有关。平时我们有可能已经注意到了，双击缩放，即用手指在屏幕上快速点击两次，可以看到内容或者图片放大，再次双击，浏览器会将网页缩放至原始比例。</p>
<p>   浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，则浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做双击事件处理。这段时间就是上面提到的300毫秒延迟。</p>
<h3 id="如何避免延迟"><a href="#如何避免延迟" class="headerlink" title="如何避免延迟"></a>如何避免延迟</h3><h3 id="方法一：静止缩放"><a href="#方法一：静止缩放" class="headerlink" title="方法一：静止缩放"></a>方法一：静止缩放</h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width user-scalable= \&#39;no\&#39;&quot;&gt; </code><br>   使用这个方法必须完全禁用缩放来达到目的，虽然大部分移动端能解决这个延迟问题，但是部分苹果手机还是不行。</p>
<h3 id="方法二：fastclick-js"><a href="#方法二：fastclick-js" class="headerlink" title="方法二：fastclick.js"></a>方法二：fastclick.js</h3><p>   FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。简而言之，FastClick 在检测到touchend事件的时候，会通过 DOM 自定义事件立即触发一个模拟click事件，并把浏览器在 300 毫秒之后真正触发的click事件阻止掉。使用方法如下。</p>
<p>   第一步：在页面中引入fastclick.js文件。</p>
<p>   第二步：在js文件中添加以下代码<br>   在 window load 事件之后，在body上调用FastClick.attach()即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line"> <span class="title class_">FastClick</span>.<span class="title function_">attach</span>( <span class="variable language_">document</span>.<span class="property">body</span> ); </span><br><span class="line">&#125;,<span class="literal">false</span> ); </span><br></pre></td></tr></table></figure>


<p>   如果你项目使用了JQuery，就将上面的代码改写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line"> <span class="title class_">FastClick</span>.<span class="title function_">attach</span>(<span class="variable language_">document</span>.<span class="property">body</span>);  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<h2 id="js的三个高阶函数"><a href="#js的三个高阶函数" class="headerlink" title="js的三个高阶函数"></a>js的三个高阶函数</h2><blockquote>
<p>map() 方法返回一个新<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTYlOTUlQjAlRTclQkIlODQmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">数组</span>，数组中的元素为原始数组元素调用函数处理后的值。</p>
<p>map() 方法按照原始数组元素顺序依次处理元素。</p>
<p>注意： map() 不会对空数组进行检测。</p>
<p>注意： map() 不会改变原始数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// 需求:让数组内的数字乘以2返回新数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">var</span> newNumbers=numbers</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newNumbers)  <span class="comment">//打印结果[8,18,32,50]</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>高阶函数reduce()</strong></p>
<p>定义和用法:<br>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p>
<p>reduce() 可以作为一个<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTklQUIlOTglRTklOTglQjYlRTUlODclQkQlRTYlOTUlQjAmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">高阶函数</span>，用于函数的 compose。</p>
<p>注意: reduce() 对于空数组是不会执行回调函数的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// 需求:求数组内所有数的和</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">var</span> newNumbers=numbers</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total,item</span>) =&gt;</span> item+total)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newNumbers)  <span class="comment">//打印结果:54</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>高阶函数filter()</strong></p>
<p>定义和用法:<br>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>
<p>注意： filter() 不会对空数组进行检测。</p>
<p>注意： filter() 不会改变原始数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="comment">// 需求:求数组内大于9的所有数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>,<span class="number">33</span>,<span class="number">24</span>,<span class="number">13</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">var</span> newNumbers=numbers</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">9</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newNumbers)  <span class="comment">//打印结果:[16,25,33,24,13]</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="前端模块发开发和组件化开发的区别"><a href="#前端模块发开发和组件化开发的区别" class="headerlink" title="前端模块发开发和组件化开发的区别?"></a>前端模块发开发和组件化开发的区别?</h2><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化:"></a>组件化:</h3><p>1:  就是”基础库”或者”基础组件”, 意思就是把重复的代码部分提炼出一个个组件供给功能使用</p>
<p>  2: 功能相对单一或者独立, 在整个系统的代码层次上位于最底层，被其他代码所依赖，所以说组件化是纵向分层。</p>
<p> 3: 使用场景: 是对一些重复代码进行封装在需要的时候调用即可(例如: 按钮, 输入框, 搜索框)</p>
<p> 4:  目得: 复用, 解耦</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化:"></a>模块化:</h3><p>​        1: 就是”业务框架”或者”业务模块”, 将不同的业务进行划分, 同一类型的整合在一起, 所以功能会相对复杂, 但是都属于			同一个业务</p>
<pre><code>     2: 按照项目功能需求划分成不同类型的业务框架（例如：注册、登录、外卖、直播.....）
</code></pre>
<p>​		 3: 目得:  隔离.分装, 模块之间有依赖的关系, 可以通过路由进行模块直接的耦合问题</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><ul>
<li>组件：就像一个个小的单位，多个组件可以组合成组件库，方便调用和复用，组件间也可以嵌套，小组件组合成大组件。</li>
<li>模块：就像是独立的功能和项目（如淘宝：注册、登录、购物、直播…），可以调用组件来组成模块，多个模块可以组合成业务框架。</li>
</ul>
<h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><p>开发和调试效率高：随着功能越来越多，代码结构会越发复杂，要修改某一个小功能，可能要重新翻阅整个项目的代码，把所有相同的地方都修改一遍，重复劳动浪费时间和人力，效率低；使用组件化，每个相同的功能结构都调用同一个组件，只需要修改这个组件，即可全局修改。</p>
<p>可维护性强：便于后期代码查找和维护。</p>
<p>避免阻断：模块化是可以独立运行的，如果一个模块产生了bug，不会影响其他模块的调用。</p>
<p>版本管理更容易：如果由多人协作开发，可以避免代码覆盖和冲突。</p>
<p> <strong>总结:</strong></p>
<ul>
<li>其实组件相当于库，把一些能在项目里或者不同类型项目中可复用的代码进行工具性的封装。</li>
<li>而模块相应于业务逻辑模块，把同一类型项目里的功能逻辑进行进行需求性的封装。</li>
</ul>
<h2 id="为什么要进行防抖和节流处理？如何实现防抖和节流？"><a href="#为什么要进行防抖和节流处理？如何实现防抖和节流？" class="headerlink" title="为什么要进行防抖和节流处理？如何实现防抖和节流？"></a>为什么要进行防抖和节流处理？如何实现防抖和节流？</h2><p><strong>防抖一定时间连续触发的事件,只在最后执行一次,</strong></p>
<blockquote>
<p>防抖使用场景:  </p>
<p>input输入框事件，键盘按下事件</p>
</blockquote>
<p><strong>节流一段时间内只执行一次。可以减少一段时间内事件的触发频率</strong></p>
<blockquote>
<p>节流使用场景： </p>
<p>onresize，scroll，mousemove ,mouseleave 鼠标不断触发</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行</li>
</ul>
<h3 id="结合应用场景"><a href="#结合应用场景" class="headerlink" title="结合应用场景"></a>结合应用场景</h3><ul>
<li>debounce  <strong>控制次数</strong><ul>
<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>throttle  <strong>控制频率</strong><ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
</li>
</ul>
<h3 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h3><p>以上这些应用场景在执行的时候会不断执行函数或者发起请求，这极大的浪费资源，降低前端性能</p>
<p>防抖和节流是优化这些高频率事件的手段</p>
<h3 id="如何实现防抖"><a href="#如何实现防抖" class="headerlink" title="如何实现防抖"></a>如何实现防抖</h3><p>![image-20220911202827653](C:\Users\m1769\AppData\Roaming\Typora\typora-user-images\image-20220911202827653.</p>
<img data-src="C:\Users\m1769\AppData\Roaming\Typora\typora-user-images\image-20220911202916797.png" alt="image-20220911202916797" style="zoom:50%;" />



<h3 id="如何实现节流？"><a href="#如何实现节流？" class="headerlink" title="如何实现节流？"></a>如何实现节流？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .<span class="property">box</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: 500px;</span><br><span class="line">      <span class="attr">height</span>: 500px;</span><br><span class="line">      background-<span class="attr">color</span>: #ccc;</span><br><span class="line">      <span class="attr">color</span>: #fff;</span><br><span class="line">      text-<span class="attr">align</span>: center;</span><br><span class="line">      font-<span class="attr">size</span>: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="comment">// 鼠标滑动数字++</span></span><br><span class="line">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span> <span class="comment">// 让变量++</span></span><br><span class="line">    <span class="comment">// 鼠标移动函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">mouseMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">      box.<span class="property">innerHTML</span> = i++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节流函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, t</span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(666);</span></span><br><span class="line">      <span class="comment">// 起始时间</span></span><br><span class="line">      <span class="keyword">let</span> startTime = <span class="number">0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 得到当前时间</span></span><br><span class="line">        <span class="keyword">let</span> newTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        <span class="comment">// 判断如果大于等于3000 </span></span><br><span class="line">        <span class="keyword">if</span> (newTime - startTime &gt;= t) &#123;</span><br><span class="line">          <span class="comment">//调用鼠标移动函数</span></span><br><span class="line">          <span class="title function_">fn</span>()</span><br><span class="line">          <span class="comment">// 起始时间 = 现在时间</span></span><br><span class="line">          startTime = newTime</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">throttle</span>(mouseMove, <span class="number">3000</span>))</span><br></pre></td></tr></table></figure>





<img data-src="C:\Users\m1769\AppData\Roaming\Typora\typora-user-images\image-20220911213723574.png" alt="image-20220911213723574" style="zoom:50%;" />

<p><strong>可以看到不管怎么移动，它只会在3秒后执行</strong></p>
<h2 id="3-v-for后面为什么要加-key"><a href="#3-v-for后面为什么要加-key" class="headerlink" title="3. v-for后面为什么要加:key"></a>3. v-for后面为什么要加:key</h2><p>提高更新DOM的性能</p>
<blockquote>
<p>就地复用策略:<br>当在进行列表渲染的时候，vue会直接对已有的标签进行复用，不会整个的将所有的标签全部重新删除和创建,只会重新渲染数据，然后再创建新的元素直到数据渲染完为止．<br>其中:key 属性可以提高v-for渲染的效率! vue不会改变原有的数据,而是创建新的元素将新的数据渲染进去.<br>1.key属性的值必须是一个唯一且不变的<br>2.它主要用来提高渲染性能<br>3.key属性可以避免数据混乱的情况出现〈如果元素中包含了有临时数据的元素，如果不用key就会产生数据混乱〉</p>
</blockquote>
<h2 id="4-computed-和-watch的区别？"><a href="#4-computed-和-watch的区别？" class="headerlink" title="4.computed 和 watch的区别？"></a>4.computed 和 watch的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.computed支持数据缓存，只有依赖数据发生改变，才会重新计算，而watch不支持缓存，数据变，直接会触发相应的操作。</span><br><span class="line">2.computed 不支持异步，当computed内有异步操作时无效，无法监听数据的变化；而watch支持异步</span><br><span class="line"></span><br><span class="line">3、computed属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值;而watch监听的函数接收两个参数，第一个参数是最新的值，第二个参数是输入之前的值。</span><br><span class="line"></span><br><span class="line">4、如果一个属性是由其它属性计算而来的，这个属性依赖其它属性，是一个多对一或者一般用computed;而当一个属性发生变化时，需要执行对应的操作;一对多一般用watch。</span><br><span class="line"></span><br><span class="line">5、如果computed属性属性值是函数，那么默认会走get方法;函数的返回值就是属性的属性值;在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。而watch监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其它操作，函数有两个参数。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDY1NTcyNTcxNjcxOTUzNDIy">详情</span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Computed: 一个变量的值，需要另一个变量计算而来，它是vue变量，不能和 data 变量名重名</span></span><br><span class="line"><span class="comment">// 函数内部 必须要return 出一个结果  如果函数内变量改变 ，则会自动重新计算</span></span><br><span class="line">语法：</span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line"> 计算属性名()&#123;</span><br><span class="line"> 	<span class="keyword">return</span> 值</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 计算属性的优势 ：</span></span><br><span class="line">  <span class="comment">// 带缓存</span></span><br><span class="line">  <span class="comment">// 计算属性 对应的函数执行后，会把return的值缓存起来</span></span><br><span class="line">  <span class="comment">// 依赖项不变 ，多次调用都是缓存取值</span></span><br><span class="line">  <span class="comment">//依赖项的值发生变化，函数会“自动” 重新执行 - 返回新的值</span></span><br><span class="line"><span class="comment">// 计算属性使用的时候可以用在输入框的双向绑定上</span></span><br><span class="line"><span class="comment">// 当我们给计算属性赋值时，需要用到计算属性的完整写法</span></span><br><span class="line">computed :&#123;</span><br><span class="line">  <span class="string">&quot;计算属性名&quot;</span> ()&#123;&#125;</span><br><span class="line">  <span class="string">&quot;计算属性名&quot;</span>: &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">值</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> 值</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>computed 能实现的，用watch一定能实现，而用watch 实现的computed 不一定能实现</p>
<p>例：给input输入一个值 在页面上一秒钟之后打印出来</p>
<p>此时会发现 倒计时是一个异步操作，用computed是不能实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;template&gt;</span><br><span class="line">&gt;&lt;div&gt;</span><br><span class="line">&gt;&lt;input type=&quot;text&quot; v-model=&quot;a&quot; /&gt;</span><br><span class="line">&gt;&lt;input type=&quot;text&quot; v-model=&quot;b&quot; /&gt;</span><br><span class="line">&gt;&lt;p&gt;&#123;&#123; ab &#125;&#125;&lt;/p&gt;</span><br><span class="line">&gt;&lt;p&gt;&#123;&#123; aa &#125;&#125;&lt;/p&gt;</span><br><span class="line">&gt;&lt;/div&gt;</span><br><span class="line">&gt;&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&gt;&lt;script&gt;</span><br><span class="line">&gt;export default &#123;</span><br><span class="line">&gt;data() &#123;</span><br><span class="line">&gt;return &#123;</span><br><span class="line">&gt;a: 10,</span><br><span class="line">&gt;b: 20,</span><br><span class="line">ab: &quot;10 20&quot;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;computed: &#123;</span><br><span class="line">&gt;aa() &#123;</span><br><span class="line">&gt;setTimeout(() =&gt; &#123;</span><br><span class="line">   return this.a + this.b;</span><br><span class="line"> &#125;, 1000);</span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;&#125;,</span><br><span class="line"></span><br><span class="line">&gt;watch: &#123;</span><br><span class="line">&gt;a(val) &#123;</span><br><span class="line">&gt;setTimeout(() =&gt; &#123;</span><br><span class="line"> this.ab = val + &quot; &quot; + this.b;</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;b(val) &#123;</span><br><span class="line">&gt;this.ab = this.a + &quot; &quot; + val;</span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="promise有什么作用？"><a href="#promise有什么作用？" class="headerlink" title="promise有什么作用？"></a>promise有什么作用？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在我们的项目中会遇到许多代码嵌套，层级调用的关系，这样会导致代码难以维护,有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有三种状态 ： </span><br><span class="line">	初始状态（pending）:不是成功状态也不是失败状态。</span><br><span class="line">	执行reslove : 状态由 pending ---&gt; fulfilled </span><br><span class="line">	成功状态（fulfilled）: 意味着操作成功完成。</span><br><span class="line">	执行 reject ： 状态由 pending ---&gt; rejected</span><br><span class="line">	失败状态（rejected）: 意味着操作失败。</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">他的状态是不可逆的 ，一旦执行成功就不会回到pending状态,也不会回到 rejected状态。</span><br><span class="line">任何时候都可以得到这个结果。所以，Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。</span><br><span class="line"></span><br><span class="line">所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果!</span><br></pre></td></tr></table></figure>

<h2 id="谈谈对async和await的理解？"><a href="#谈谈对async和await的理解？" class="headerlink" title="谈谈对async和await的理解？"></a>谈谈对async和await的理解？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async</span><br><span class="line">作为一个关键字放在函数的前面，使用async修饰的函数是一个异步函数，意味着该函数的执行不会阻塞后面代码的执行，异步函数的调用跟普通函数是一样。</span><br><span class="line"></span><br><span class="line">await</span><br><span class="line">await即等待，用于等待一个Promise对象。它只能在被async修饰的函数中使用，否则会报错，它的返回值不是Promise对象而是Promise对象处理之后的结果。被await修饰的函数等需要强制等待这个函数执行后，才执行async代码块中其他的代码，而代码块之外的代码不会阻塞。</span><br></pre></td></tr></table></figure>

<h2 id="route和-router的区别？"><a href="#route和-router的区别？" class="headerlink" title="$route和$router的区别？"></a>$route和$router的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$route是用来获取路由信息的。是一个跳转的路由对象（路由信息对象），包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等,</span><br><span class="line"></span><br><span class="line">$router是用来操作路由的，包括路由的跳转方法</span><br></pre></td></tr></table></figure>

<h2 id="vue中的常用指令有哪些？"><a href="#vue中的常用指令有哪些？" class="headerlink" title="vue中的常用指令有哪些？"></a>vue中的常用指令有哪些？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v-bind  <span class="comment">// 单项绑定</span></span><br><span class="line">v-model  <span class="comment">// 双向绑定</span></span><br><span class="line">v-on  <span class="comment">//绑定事件</span></span><br><span class="line">v-<span class="keyword">if</span>/v-show  <span class="comment">// 显示或隐藏 true: false</span></span><br><span class="line">v-<span class="keyword">for</span>  <span class="comment">// 列表循环</span></span><br><span class="line">v-text/v-html   <span class="comment">// 更新元素的 textConten : innerHTML</span></span><br><span class="line">v-slot   <span class="comment">// 路由插槽</span></span><br><span class="line">v-once </span><br><span class="line"><span class="comment">// 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</span></span><br><span class="line"><span class="comment">// 给盒子加上属性后，不必每次渲染都销毁或新建，可以提高静态内容的展示效率。</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是路由懒加载，为什么要使用路由懒加载？"><a href="#什么是路由懒加载，为什么要使用路由懒加载？" class="headerlink" title="什么是路由懒加载，为什么要使用路由懒加载？"></a>什么是路由懒加载，为什么要使用路由懒加载？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">路由懒加载会提高项目性能，他是以一种异步方式对组件进行引入，意思就是当跳转到这个路由地址的时候，才会对这个组件进行加载应用</span><br><span class="line">，没有跳转就不会进行加载应用</span><br><span class="line"></span><br><span class="line">为什么使用路由懒加载?</span><br><span class="line">当项目开发完后会对项目进行打包，如果不用路由懒加载，会导致项目体积比较大，打开首页会有短暂空白现象，因此，我们需要路由懒加载。</span><br><span class="line">（按需加载）</span><br></pre></td></tr></table></figure>

<h2 id="说说v-model的原理？"><a href="#说说v-model的原理？" class="headerlink" title="说说v-model的原理？"></a>说说v-model的原理？</h2><blockquote>
<p>（1）Vue中使用v-model指令来实现表单元素和数据的双向绑定, 将表单中用户提交的信息和程序员设定的变量进行			绑定			</p>
<p>（2）：v-model其实是一个语法糖，他背后的本质上是包含两个操作:<br>            v-bind绑定一个value属性<br>            v-on指令给当前元素绑定input事件</p>
<p>（3）：使用v-model后，<strong>表单控件显示的值只依赖所绑定的数据，不在关心初始时的value属性。</strong> v-model 会忽略				所有表单元素的 value、checked、selected attribute 的初始值。</p>
<p>（4.）vue.js采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;message = $event.target.value&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>输入的内容是:&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）：对于纯文本也是	：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea v-model=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;请输入&quot;</span>&gt;frvf&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>

<p>（更多&#x3D;&gt;）[<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2ViY2FiYW5hL3AvMTEwNzc2MjguaHRtbF0=">https://www.cnblogs.com/webcabana/p/11077628.html]</span></p>
<h2 id="谈谈你对vue中的虚拟DOM的理解"><a href="#谈谈你对vue中的虚拟DOM的理解" class="headerlink" title="谈谈你对vue中的虚拟DOM的理解"></a>谈谈你对vue中的虚拟DOM的理解</h2><p><strong>什么是虚拟DOM</strong>:</p>
<p>​	⽤ JavaScript 对象表示 DOM 信息和结构，更新后使之与真实dom保持同步，同步过程就是协调，核心是diff算法</p>
<p><strong>为什么要用虚拟DOM：</strong></p>
<p>​	 DOM操作很慢，轻微的操作都可能导致⻚面重新排 版，⾮常耗性能。相对于DOM对象，js对象处理起来更快， 而且更	简单。通过diff算法对比新旧dom之间的差异，可以批量的、最⼩化的执行dom操作，从而提高性能.</p>
<h3 id="虚拟DOM中key的作用："><a href="#虚拟DOM中key的作用：" class="headerlink" title="虚拟DOM中key的作用："></a>虚拟DOM中key的作用：</h3><blockquote>
<p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：<br>2.对比规则：<br>(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。<br>(2).旧虚拟DOM中未找到与新虚拟DOM相同的key<br>创建新的真实DOM，随后渲染到到页面。</p>
<p><strong>用index作为key可能会引发的问题：</strong></p>
<ol start="2">
<li>若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>  会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</li>
<li>如果结构中还包含输入类的DOM：<br>  会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</li>
<li>开发中如何选择key?:<br>  1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>  2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>  使用index作为key是没有问题的。</li>
</ol>
</blockquote>
<h2 id="vuex是做什么的？vuex中有哪些属性，分别有什么作用？"><a href="#vuex是做什么的？vuex中有哪些属性，分别有什么作用？" class="headerlink" title="vuex是做什么的？vuex中有哪些属性，分别有什么作用？"></a>vuex是做什么的？vuex中有哪些属性，分别有什么作用？</h2><p>（1）：vuex是做什么的？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以实现组件之间的数据共享，尤其是非关系型组件之间的共享,它采用`集中式`存储管理应用的所有组件的状态</span><br></pre></td></tr></table></figure>

<p>（2）: vuex的属性及作用？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">state : 共享数据，可以在组件中调用  </span><br><span class="line">    &lt;div&gt; state的数据：&#123;&#123; $store.<span class="property">state</span>.<span class="property">count</span> &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">mutations</span>: mutations是一个对象，对象中存放修改state的方法,state数据的修改只能通过mutations，并且mutations必须是同步更新</span><br><span class="line">	  <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;addCount&#x27;</span>, <span class="number">10</span>)  <span class="comment">// 直接调用mutations</span></span><br><span class="line">	  <span class="comment">//辅助函数</span></span><br><span class="line">      <span class="keyword">import</span>  &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">		<span class="attr">methods</span>: &#123;</span><br><span class="line">   		 ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;addCount&#x27;</span>])</span><br><span class="line">	&#125;</span><br><span class="line">actions：不能直接修改state,通过提交mutation来实现，可以包含异步操作</span><br><span class="line">	<span class="comment">//原始调用</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;getAsyncCount&#x27;</span>)</span><br><span class="line">	<span class="comment">// 传参调用</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;getAsyncCount&#x27;</span>，<span class="number">123</span>)</span><br><span class="line"><span class="attr">getters</span>:可以对state里的数据进行预先处理，相当于state的计算属性</span><br><span class="line">	<span class="comment">// 原始掉用</span></span><br><span class="line">	&#123;&#123; $store.<span class="property">getters</span>.属性名&#125;&#125;</span><br><span class="line">modules： 模块，每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><h3 id="浅拷贝-将原对象或原数组的引用直接赋给新对象，新数组，新对象-x2F-数组只是原对象的一个引用。"><a href="#浅拷贝-将原对象或原数组的引用直接赋给新对象，新数组，新对象-x2F-数组只是原对象的一个引用。" class="headerlink" title="浅拷贝:将原对象或原数组的引用直接赋给新对象，新数组，新对象&#x2F;数组只是原对象的一个引用。"></a>浅拷贝:将原对象或原数组的引用直接赋给新对象，新数组，新对象&#x2F;数组只是原对象的一个引用。</h3><h3 id="深拷贝-创建一个新的对象和数组，将原对象的各项属性的“值”-数组的所有元素-拷贝过来，是“值”而不是“引用”。"><a href="#深拷贝-创建一个新的对象和数组，将原对象的各项属性的“值”-数组的所有元素-拷贝过来，是“值”而不是“引用”。" class="headerlink" title="深拷贝:创建一个新的对象和数组，将原对象的各项属性的“值”(数组的所有元素)拷贝过来，是“值”而不是“引用”。"></a>深拷贝:创建一个新的对象和数组，将原对象的各项属性的“值”(数组的所有元素)拷贝过来，是“值”而不是“引用”。</h3><h3 id="实现深拷贝的三种方式"><a href="#实现深拷贝的三种方式" class="headerlink" title="实现深拷贝的三种方式"></a>实现深拷贝的三种方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON.parse(JSON.stringify())</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1);</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line">obj2.<span class="property">a</span> = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);  <span class="comment">//&#123;a: 3, b: 4&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2);  <span class="comment">//&#123;a: 5, b: 4&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;pink&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">hobby</span>: [<span class="string">&#x27;火锅&#x27;</span>, <span class="string">&#x27;炸鸡&#x27;</span>],</span><br><span class="line">  <span class="attr">family</span>: &#123;</span><br><span class="line">    <span class="attr">baby</span>: <span class="string">&#x27;老pink&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;</span><br><span class="line"><span class="comment">// 拷贝函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">newObj, oldObj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldObj[k] <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">      newObj[k] = []</span><br><span class="line">      <span class="title function_">deepCopy</span>(newObj[k], oldObj[k])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldObj[k] <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">      newObj[k] = &#123;&#125;</span><br><span class="line">      <span class="title function_">deepCopy</span>(newObj[k], oldObj[k])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//  k 属性名: oldObj[k]:属性值</span></span><br><span class="line">      <span class="comment">// newObj[k] === o.name</span></span><br><span class="line">      newObj[k] = oldObj[k]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">deepCopy</span>(o, obj)</span><br><span class="line">o.<span class="property">age</span> = <span class="number">30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 引入lodash</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;pink&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">      <span class="attr">hobby</span>: [<span class="string">&#x27;火锅&#x27;</span>, <span class="string">&#x27;炸鸡&#x27;</span>],</span><br><span class="line">      <span class="attr">family</span>: &#123;</span><br><span class="line">        <span class="attr">baby</span>: <span class="string">&#x27;老pink&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> o = _.<span class="title function_">cloneDeep</span>(obj)</span><br><span class="line">    o.<span class="property">family</span>.<span class="property">baby</span> = <span class="string">&#x27;小pink&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br></pre></td></tr></table></figure>

<h2 id="VUE中-nextTick的使用场景"><a href="#VUE中-nextTick的使用场景" class="headerlink" title="VUE中$nextTick的使用场景"></a>VUE中$nextTick的使用场景</h2><p>应用场景：需要在视图更新之后，基于新的视图进行操作。通过<code>this.$nextTick()</code>获取到的值为dom更新之后的值。在<code>created()</code>钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行<code>DOM</code>操作并无作用，而在created()里使用 </p>
<p><code>this.$nextTick()</code>可以等待dom生成以后再来获取dom对象</p>
<p>可以拿到更新后的DOM</p>
<h2 id="vue中的-set的方法"><a href="#vue中的-set的方法" class="headerlink" title="vue中的$set的方法"></a>vue中的$set的方法</h2><p> Vue是响应式的，数据变化，页面会自动更新</p>
<p>但是，Vue2.0中，有两种情况，数据变化，页面不会更新。第一种，直接动态给已存在对象新增属性，新增的属性不支持响应式；第二种，直接通过数组的下标索引修改元素内容，页面也不会更新</p>
<ol start="3">
<li>那怎么办呢？Vue专门提供了$set方法，如果遇到上述两种情况，用$set来修改数据，页面就能够支持响应式了</li>
<li>第二条描述的问题在Vue3.0中不存在</li>
</ol>
<h2 id="路由配置name属性是为什么"><a href="#路由配置name属性是为什么" class="headerlink" title="路由配置name属性是为什么"></a>路由配置name属性是为什么</h2><p><strong>我们可以使用这个name 属性来动态的绑定 当前路由，而不是只能跳转固定的 path路径</strong>，也就是说，我一旦 给某个路由设置了 name 属性，那么我在跳转路由的时候，如果是 通过绑定的 name 属性值 进行跳转，而 不是根据绑定的 path 路径 来跳转的话，那么，我的跳转就可以是动态的了，即使这个路由的 path 更改了，我的 name也是指向当前更改后的路由</p>
<h2 id="es6的新特性？"><a href="#es6的新特性？" class="headerlink" title="es6的新特性？"></a>es6的新特性？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.let var const 的区别</span><br><span class="line">2.模板字符串</span><br><span class="line">3.展开运算符</span><br><span class="line">4.箭头函数</span><br><span class="line">5.数组对象的解构赋值</span><br><span class="line">6.promise</span><br><span class="line">7.Set</span><br><span class="line">8.Map</span><br><span class="line">class类</span><br></pre></td></tr></table></figure>

<h2 id="什么是重绘和回流"><a href="#什么是重绘和回流" class="headerlink" title="什么是重绘和回流"></a>什么是重绘和回流</h2><p><em><strong>重绘</strong></em>：<br>DOM树没有元素增加或删除，只是样式的改变，针对浏览器对某一元素进行单独的渲染，这个过程就叫做重绘<br><em><strong>回流：</strong></em><br>DOM树中的元素被增加或者删除，导致浏览器需要重新的去渲染整个DOM树，回流比重绘更消耗性能，发生回流必定重绘，重绘不一定会导致回流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。</span><br><span class="line"></span><br><span class="line">触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如：</span><br><span class="line">1、页面渲染初始化；(无法避免)</span><br><span class="line"></span><br><span class="line">2、添加或删除可见的DOM元素；</span><br><span class="line"></span><br><span class="line">3、元素位置的改变，或者使用动画；</span><br><span class="line"></span><br><span class="line">4、元素尺寸的改变——大小，外边距，边框；</span><br><span class="line"></span><br><span class="line">5、浏览器窗口尺寸的变化（resize事件发生时）；</span><br><span class="line"></span><br><span class="line">6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；</span><br><span class="line"></span><br><span class="line">7、读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>

<h2 id="如何改变this指向？"><a href="#如何改变this指向？" class="headerlink" title="如何改变this指向？"></a>如何改变this指向？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.call 函数call（把this指向谁,实参，实参）</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;pink&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y)</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用函数改变this指向</span></span><br><span class="line">    fn.<span class="title function_">call</span>(obj, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// 2.apply: apply()用法同call()，只是apply的第二个参数是数组，数组里面是函数的参数</span></span><br><span class="line">	 <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">// age:18</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);</span><br><span class="line">    &#125;</span><br><span class="line">    fn.<span class="title function_">apply</span>(obj, [<span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment">// 3.bind :并不是改变this的指向，而是创建一个新的函数体,会延迟执行，它会返回一个新的方法，需要手动调用才会触发，传参方式和call一样,</span></span><br><span class="line">	<span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张飞&#x27;</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;跑了，&#x27;</span> + a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	obj.<span class="title function_">run</span>(<span class="string">&#x27;obj&#x27;</span>);  <span class="comment">// 张飞跑了，飞</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">   	 <span class="attr">name</span>: <span class="string">&#x27;黄忠&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> bindFun = obj.<span class="property">run</span>.<span class="title function_">bind</span>(obj1);</span><br><span class="line">	<span class="title function_">bindFun</span>(<span class="string">&#x27;忠&#x27;</span>);  <span class="comment">// 黄忠跑了，忠 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.存储this指向到变量中</span></span><br><span class="line"><span class="keyword">var</span> oDiv1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line">oDiv1.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span>; <span class="comment">//将this储存在变量中，而且不改变定时器的指向</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(_this); <span class="comment">//注意这里是_this，而不是this-- &lt;div id=&quot;div1&quot;&gt;点击&lt;/div&gt;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//定时器的指向没有被改变--仍然是window</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new操作符都干了什么？"><a href="#new操作符都干了什么？" class="headerlink" title="new操作符都干了什么？"></a>new操作符都干了什么？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个空对象</span><br><span class="line">2.this指向这个对象</span><br><span class="line">3.执行构造函数里面的代码</span><br><span class="line">4.返回一个新对象</span><br></pre></td></tr></table></figure>

<h2 id="请描述一下keep-alive的使用场景"><a href="#请描述一下keep-alive的使用场景" class="headerlink" title="请描述一下keep-alive的使用场景"></a>请描述一下keep-alive的使用场景</h2><blockquote>
<p>1:基础使用 结合动态组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">&gt;<span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">&gt;<span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">currentView</span>: <span class="title class_">Test</span> <span class="comment">//Test为引入的子组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure>

<p>2：配合router-view使用：有些时候可能需要将整个路由页面一切缓存下来使用v-if判断缓存那些路由</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;$router.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;!$router.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&gt;<span class="comment">//router配置</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">&gt;<span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: A,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">          <span class="attr">keepAlive</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/b&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: B</span><br><span class="line">  &#125;</span><br><span class="line">&gt;]</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure>

<p>这样配置路由的路由元信息之后，a路由的 $router.meta.keepAlive 便为 true ，而b路由则为 false 。<br>所以为 true 的将被包裹在 keep-alive 中，为 false 的则在外层。这样a路由便达到了被缓存的效果，如果还有想要缓存的路由，只需要在路由元中加入 keepAlive: true 即可</p>
<p>3：生命周期钩子：</p>
<p>在被keep-alive包含的组件&#x2F;路由中，会多出两个生命周期的钩子:activated 与 deactivated</p>
<p>activated在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用</p>
<p>deactivated：组件被停用(离开路由)时调用</p>
<p>注意：使用了keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了。</p>
</blockquote>
<h2 id="vue自定义指令有用过吗？请举个例子"><a href="#vue自定义指令有用过吗？请举个例子" class="headerlink" title="vue自定义指令有用过吗？请举个例子"></a>vue自定义指令有用过吗？请举个例子</h2><h3 id="vue除了核心功能默认内置的指令-v-model-和-v-show-，Vue-也允许注册自定义指令。在-Vue2-0-中，代码复用和抽象的主要形式是组件。然而，有的情况下，仍然需要对普通-DOM-元素进行底层操作，这时候就会用到自定义指令"><a href="#vue除了核心功能默认内置的指令-v-model-和-v-show-，Vue-也允许注册自定义指令。在-Vue2-0-中，代码复用和抽象的主要形式是组件。然而，有的情况下，仍然需要对普通-DOM-元素进行底层操作，这时候就会用到自定义指令" class="headerlink" title="vue除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令"></a>vue除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令</h3><h3 id="自定义指令分为：定义，注册和使用三步"><a href="#自定义指令分为：定义，注册和使用三步" class="headerlink" title="自定义指令分为：定义，注册和使用三步"></a>自定义指令分为：定义，注册和使用三步</h3><ul>
<li>定义自定义指令有两种方式：对象函数形式，前者类似组件定义，有各种声明周期，后者只会在mounted和updated时执行</li>
<li>注册自定义指令类似组件，可以使用全局注册Vue.directive()全局注册，使用{directives:{}}局部注册</li>
<li>使用时在注册名称前加上v-即可，比如v-foucs</li>
</ul>
<h3 id="在项目中常用的有？"><a href="#在项目中常用的有？" class="headerlink" title="在项目中常用的有？"></a>在项目中常用的有？</h3><ul>
<li>v-debounce输入框防抖</li>
<li>v-copy 复制粘贴</li>
<li>图片的onerror事件,当图片出现异常时通过自定义指定默认一张图片进行展示</li>
<li>v-lazy 图片懒加载</li>
</ul>
<blockquote>
<p><strong>全局注册注册</strong>主要是用过Vue.directive方法进行注册</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">&gt;<span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">&gt;<span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">&gt;<span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 聚焦元素</span></span><br><span class="line">&gt;el.<span class="title function_">focus</span>()  <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>局部注册</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attr">directives</span>: &#123;</span><br><span class="line">&gt;<span class="attr">focus</span>: &#123;</span><br><span class="line">&gt;<span class="comment">// 指令的定义</span></span><br><span class="line">&gt;<span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">el.<span class="title function_">focus</span>() <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="如何实现一个左边固定200px宽度，右边自适应的布局？"><a href="#如何实现一个左边固定200px宽度，右边自适应的布局？" class="headerlink" title="如何实现一个左边固定200px宽度，右边自适应的布局？"></a>如何实现一个左边固定200px宽度，右边自适应的布局？</h2><blockquote>
<p>方法一：float 自适应</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;fixed l1&quot;&gt;固定宽度<span class="number">200px</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;auto r1&quot;&gt;自适应宽度&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&gt;<span class="selector-class">.l1</span>&#123;</span><br><span class="line">&gt;<span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&gt;<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&gt;<span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&gt;<span class="attribute">background-color</span>: aqua;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="selector-class">.auto</span>&#123;</span><br><span class="line">&gt;<span class="attribute">background-color</span>: black;</span><br><span class="line">&gt;<span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&gt;<span class="attribute">width</span>:<span class="number">100%</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：flex</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-tag">body</span>&#123;</span><br><span class="line">&gt;<span class="attribute">display</span>: flex;</span><br><span class="line">&gt;<span class="attribute">flex-flow</span>: row;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="selector-id">#left</span>&#123;                </span><br><span class="line">&gt;<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&gt;<span class="attribute">background</span>: blue;</span><br><span class="line">&gt;&#125;            </span><br><span class="line">&gt;<span class="selector-id">#right</span>&#123;</span><br><span class="line">&gt;<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&gt;<span class="attribute">background</span>: red;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="关于MVVM设计模式？"><a href="#关于MVVM设计模式？" class="headerlink" title="关于MVVM设计模式？"></a>关于MVVM设计模式？</h2><p>MVVM其实表示的是 Model-View-ViewModel</p>
<ul>
<li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li>
<li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li>
<li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</li>
</ul>
<p>View层和Model层并没有直接联系，而是通过ViewModel层进行交互。ViewModel层通过双向数据绑定将View层和Model层连接了起来，使得View层和Model层的同步工作完全是自动的。因此开发者只需关注业务逻辑，无需手动操作DOM，复杂的数据状态维护交给MVVM统一来管理，</p>
<p>Vue.js的实现方式，对数据（Model）进行劫持，当数据变动时，数据会触发劫持时绑定的方法，对视图进行更新。</p>
<ul>
<li>利用JS底层object.defineProperty里面的set和get 方法实现的</li>
<li>Vue2源码实现逻辑：数据代理-数据劫持- 发布订阅-绑定关系<ul>
<li>数据代理-&gt; this.name就可以设置为this.$data.name</li>
<li>把$data中的数据代理给了this这个实例对象</li>
</ul>
</li>
</ul>
<h2 id="关于vuex状态共享框架"><a href="#关于vuex状态共享框架" class="headerlink" title="关于vuex状态共享框架"></a>关于vuex状态共享框架</h2><ul>
<li>它是一个状态共享框架，可以实现组件之间的数据共享，尤其是非关系型组件之间的共享，但是不一定所有的东西都会用vuex来管理</li>
<li>vue2.0是一个独一无二的状态共享框架</li>
<li>三个核心板块<ul>
<li>state 放置状态的位置-所有共享的状态只能放在state中</li>
<li>mutation 改变状态必须通过mutations - 只写同步代码-devtools打印-输入固定-输出固定</li>
<li>actions 所有的异步都放在actions中-得到的状态也必须通过mutations来修改</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store =  <span class="keyword">new</span>.<span class="property">vuex</span>.<span class="property">store</span>&#123;</span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;志雄&quot;</span></span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="attr">mutations</span>:&#123;</span><br><span class="line">        <span class="title function_">updateName</span>(<span class="params">state,payload</span>)&#123;</span><br><span class="line">            state.<span class="property">name</span> = payload</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>:&#123;</span><br><span class="line">        <span class="comment">// vue组件 this.$store = context 它们式是等价的</span></span><br><span class="line">        <span class="title function_">getAsyncName</span>(<span class="params">context</span>)&#123;</span><br><span class="line">            <span class="title function_">setTimeiout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//得到后台返回的数据-修改state-要经过mutations</span></span><br><span class="line">                context.<span class="title function_">commit</span>(updateName,<span class="string">&#x27;zhixiong&#x27;</span>)</span><br><span class="line">            &#125;,<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="什么是插槽？什么是具名插槽？什么是作用域插槽？什么是具名作用域插槽？"><a href="#什么是插槽？什么是具名插槽？什么是作用域插槽？什么是具名作用域插槽？" class="headerlink" title="什么是插槽？什么是具名插槽？什么是作用域插槽？什么是具名作用域插槽？"></a>什么是插槽？什么是具名插槽？什么是作用域插槽？什么是具名作用域插槽？</h2><p>插槽用于决定将所携带的内容，插入到指定的某个位置，使得模块分块，具有模块化特质</p>
<p>具名插槽，就是给这个插槽起个名字，slot属性对应的内容都会和组件中name一一对应</p>
<p>作用域插槽，在组件上的属性，可以在组件元素内使用！</p>
<p>插槽中的内容不能访问父级作用域，父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</p>
<h2 id="什么是JS的作用域？"><a href="#什么是JS的作用域？" class="headerlink" title="什么是JS的作用域？"></a>什么是JS的作用域？</h2><ul>
<li><p>指的是一个变量的作用范围，作用域决定了代码区块中变量和其他资源的可见性。</p>
<p>局部作用域  ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数作用域  ：使用关键词声明在函数内部的变量 就叫局部变量 他所拥有的作用域交局部作用域</span><br><span class="line">  </span><br><span class="line">块级作用域：使用 let 或者const 声明在花括号里面的变量就叫局部变量 ，她所拥有的作用域就是块级作用域</span><br></pre></td></tr></table></figure>

<p>全局作用域 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">声明在script 标签里面的变量 或者是在js 文件里的变量就叫全局变量 他所在的作用域就叫全局作用域</span><br></pre></td></tr></table></figure>

<p>作用域链:本质上是底层变量的查找机制</p>
</li>
</ul>
<h2 id="JS中数组的常用方法有哪些，分别有什么作用？"><a href="#JS中数组的常用方法有哪些，分别有什么作用？" class="headerlink" title="JS中数组的常用方法有哪些，分别有什么作用？"></a>JS中数组的常用方法有哪些，分别有什么作用？</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3d6aGl4aW9uZy5naXRodWIuaW8vMjAyMi8wOS8xNi8lRTYlOTUlQjAlRTclQkIlODQlRTclOUElODQlRTQlQjglODAlRTQlQkElOUIlRTYlOTYlQjklRTYlQjMlOTUv">数组的方法</span></p>
<h2 id="如何取出对象中所有的属性，举例说明"><a href="#如何取出对象中所有的属性，举例说明" class="headerlink" title="如何取出对象中所有的属性，举例说明"></a>如何取出对象中所有的属性，举例说明</h2><ul>
<li><p><code>Object.keys/values/entries</code></p>
</li>
<li><p>这三个方法都是用来获取对象上的属性集合的。只不过，<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys</code></a> 是用来获取属性名集合，<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values"><code>Object.values</code></a> 是用来获取属性值集合，<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries</code></a> 则是用来获取属性键-值对集合的。</p>
</li>
<li><p><code>for(let prop in obj)&#123; 通过对象自身以及所在原型链上所有的属性&#125;</code></p>
</li>
<li><p>Object.getOwnPropertySymbols()是<strong>获取对象自身上的Symbol属性，包括可枚举的与不可枚举的</strong>，最后返回一个数组。</p>
</li>
<li><p>Object.getOwnPropertyNames()是获取<strong>对象自身上的字符串属性，包括可枚举的与不可枚举的属性</strong>，最后返回一个数组。</p>
</li>
<li><p>Reflect.ownKeys(obj) 等同于 <code>Object.getOwnPropertyNames(obj)</code> + <code>Object.getOwnPropertySymbols(obj)</code> 的效果。</p>
</li>
</ul>
<h2 id="关于Object-defineProperty"><a href="#关于Object-defineProperty" class="headerlink" title="关于Object.defineProperty()"></a>关于Object.defineProperty()</h2><p><code>Object.defineProperty()</code>的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性,</p>
<p>一般通过为对象的属性赋值的情况下，对象的属性可以修改也可以删除，但是通过Object.defineProperty()定义属性，通过描述符的设置可以进行更精准的控制对象属性。</p>
<p>经常使用的定义与赋值方法<code>obj.prop =value</code>或者<code>obj[&#39;prop&#39;]=value</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>. name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="title class_">Person</span> [ <span class="string">&#x27;gender&#x27;</span> ] = <span class="string">&#x27;female&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>)  <span class="comment">//Jack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>. gender) <span class="comment">//female</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span><span class="selector-class">.defineProperty</span>(obj, prop, desc)</span><br><span class="line">obj 需要定义属性的当前对象</span><br><span class="line">prop 当前需要定义的属性名</span><br><span class="line">desc 属性描述符</span><br></pre></td></tr></table></figure>

<p>有两种描述符：</p>
<ul>
<li><p>数据描述符 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">   <span class="attr">value</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">   <span class="attr">writable</span>: <span class="literal">true</span> <span class="comment">// 是否可以改变</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举个栗子</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = &#123;&#125;</span><br><span class="line">0bject.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>,<span class="string">&#x27;name &#x27;</span> , &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">    <span class="attr">writablem</span>:<span class="literal">true</span> </span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Person</span> . name = <span class="string">&#x27;rose&#x27;</span> <span class="comment">// writablem默认是false，不能改变属性的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">//如果为true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>) <span class="comment">// rose</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>存取描述符 是由一对 getter、setter 函数功能来描述的属性</p>
</li>
<li><p>getter 是一种获得属性值的方法，setter是一种设置属性值的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp = <span class="literal">null</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">    temp = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = &#123;l&#125;</span><br><span class="line"><span class="keyword">let</span> temp = <span class="literal">null</span></span><br><span class="line">0bject.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>,<span class="string">&#x27;name &#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> temp</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">    temp = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Person</span>. name = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> (<span class="title class_">Person</span>. name)jack</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="vue如何全局注册一个组件？"><a href="#vue如何全局注册一个组件？" class="headerlink" title="vue如何全局注册一个组件？"></a>vue如何全局注册一个组件？</h2><p>项目中需要多次使用，进行一次封装，全局使用。迎合了es6的模块化开发思想。</p>
<p>1：为了统一管理全局组件，建议将封装的全局组件都写在src根目录下一个专门的文件夹中，比如<code>src/components</code></p>
<p>在<code>main.js</code>中引入，注册为全局组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 组件名 <span class="keyword">from</span> <span class="string">&#x27;@/components/xxx&#x27;</span> <span class="comment">// 注册为全局组件* **Vue**.**component**(&#x27;组件名&#x27;,组件名)</span></span><br></pre></td></tr></table></figure>

<h2 id="webpack了解吗？有什么作用？"><a href="#webpack了解吗？有什么作用？" class="headerlink" title="webpack了解吗？有什么作用？"></a>webpack了解吗？有什么作用？</h2><h3 id="1、什么是webpack"><a href="#1、什么是webpack" class="headerlink" title="1、什么是webpack"></a>1、什么是webpack</h3><p>​	webpack是一个打包模块化javascript的工具，在webpack里一切文件皆模块，通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合成的文件，webpack专注构建模块化项目</p>
<h3 id="2、Webpack的优点是什么？"><a href="#2、Webpack的优点是什么？" class="headerlink" title="2、Webpack的优点是什么？"></a>2、Webpack的优点是什么？</h3><ol>
<li>专注于处理模块化的项目，能做到开箱即用，一步到位</li>
<li>通过plugin扩展，完整好用又不失灵活</li>
<li>通过loaders扩展, 可以让webpack把所有类型的文件都解析打包</li>
<li>区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展</li>
</ol>
<h2 id="浏览器渲染过程中什么是重绘和回流？"><a href="#浏览器渲染过程中什么是重绘和回流？" class="headerlink" title="浏览器渲染过程中什么是重绘和回流？"></a>浏览器渲染过程中什么是重绘和回流？</h2><blockquote>
<h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><ol>
<li>将HTML代码解析成DOM树</li>
<li>将CSS代码解析成CSSOM树</li>
<li>结合DOM树和CSSOM树，生成一颗render树</li>
<li>布局，将渲染树的所有节点进行屏幕合成</li>
<li>绘制页面到屏幕上</li>
</ol>
<h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>回流我们可以理解为重新排列布局，即重新执行“从输入url到页面渲染发生的操作”里的第四步——<strong>布局</strong>；</p>
<p>JS动态控制DOM结构的时候，且有DOM结点的几何信息元素发生改变时，才会执行回流。</p>
<h4 id="执行回流的操作"><a href="#执行回流的操作" class="headerlink" title="执行回流的操作"></a>执行回流的操作</h4><ol>
<li><code>window</code>大小被修改</li>
<li>增加删除<code>DOM</code>结构</li>
<li>元素的尺寸发生变化</li>
<li><code>offsetWidth</code> 和 <code>offsetHeight</code> ,<code>offset...</code> ,<code>clientWidth</code>,<code>client...</code>,<code>scrollTop</code>,<code>scroll...</code></li>
</ol>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>即重新执行渲染，可以理解为重新执行“从输入url到页面渲染发生的操作”里的第五步——<strong>绘制页面到屏幕上</strong>；</p>
<p><strong>简单来说，所有导致元素非几何信息发生变化的操作都会触发重绘。</strong>DOM结构并没有重新进行重新布局排版，但是数据信息却重新进行了渲染，这就是<strong>重绘</strong> ，回流一定会重绘，但是重绘不一定会回流</p>
<h3 id="怎么去减少回流和重绘呢"><a href="#怎么去减少回流和重绘呢" class="headerlink" title="怎么去减少回流和重绘呢"></a>怎么去减少回流和重绘呢</h3><p>1.脱离文档流 –&gt; 改变样式 –&gt; 回归文档流</p>
</blockquote>
<h2 id="如何封装axios请求？"><a href="#如何封装axios请求？" class="headerlink" title="如何封装axios请求？"></a>如何封装axios请求？</h2><ol>
<li><p>安装axios  <code>yarn add axios || npm i axios</code></p>
</li>
<li><p>在src目录下新建 utils文件夹 再建一个<code>request.js</code>文件</p>
</li>
<li><p>在request.js中引入axios <code>import axios from &quot;axios&quot;</code></p>
</li>
<li><p>&#96;&#96;&#96;js<br>&#x2F;&#x2F;创建axios实例<br>const instance &#x3D; axios.create({<br>  baseURL: ‘<span class="exturl" data-url="aHR0cHM6Ly9zb21lLWRvbWFpbi5jb20vYXBpLyYjMzk7LC8vJUU1JTg1JUFDJUU1JTg1JUIxJUU1JTlDJUIwJUU1JTlEJTgw">https://some-domain.com/api/&#39;,//公共地址</span><br>  timeout: 1000,&#x2F;&#x2F;请求超时时间<br>  headers: {‘X-Custom-Header’: ‘foobar’}&#x2F;&#x2F;请求头，可以不写<br>});<br>&#x2F;&#x2F; 添加请求拦截器<br>instance.interceptors.request.use(function (config) {<br>&#x2F;&#x2F; 在发送请求之前做些什么<br>return config;<br>  }, function (error) {<br>&#x2F;&#x2F; 对请求错误做些什么<br>return Promise.reject(error);<br>  });</p>
<p>&#x2F;&#x2F; 添加响应拦截器<br>instance.interceptors.response.use(function (response) {<br>&#x2F;&#x2F; 对响应数据做点什么<br>return response;<br>  }, function (error) {<br>&#x2F;&#x2F; 对响应错误做点什么<br>return Promise.reject(error);<br>  });</p>
<p>&#x2F;&#x2F;导出axios实例<br>export default instance</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 在vue组件中使用即可</span><br><span class="line"></span><br><span class="line">## 说说深拷贝的应用场景？</span><br><span class="line"></span><br><span class="line">想使用某个对象的值，在修改时不想修改原对象，那么可以用深拷贝弄一个新的内存对象</span><br><span class="line"></span><br><span class="line">从服务器forEach到数据之后我将其存放在store中，通过props传递给界面，然后我需要对这堆数据进行修改，那涉及到的修改就一定有保存和取消，所以我们需要将这堆数据拷贝到其它地方。</span><br><span class="line"></span><br><span class="line">## vue的数据为什么要放在data函数里?为什么在data函数里的return里面的数据可以直接被vue实例使用?</span><br><span class="line"></span><br><span class="line">1.数据私有化，该数据只在当前组件内使用</span><br><span class="line"></span><br><span class="line">2.受到函数作用域的影响</span><br><span class="line"></span><br><span class="line">为什么不能用对象？如果data是一个对象，那么就会走源码中的else代码，直接将用户传入的data进行使用，如果有多个组件，就会造成data数据共享，这样会形成数据污染</span><br><span class="line"></span><br><span class="line">## delete和Vue.delete的区别</span><br><span class="line"></span><br><span class="line">delete和和Vue.delete都是对[数组](https://so.csdn.net/so/search?q=数组&amp;spm=1001.2101.3001.7020)或对象进行删除的方法。这两种方法对于对象来说其实是没有区别的，使用方法会直接删除对象的属性（物理删除）</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">let obj = &#123;</span><br><span class="line">name: &#x27;fufu&#x27;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line">// delete obj.age  =&gt; &#123;name: &#x27;fufu&#x27;&#125;</span><br><span class="line">// Vue.delete(obj, &#x27;age&#x27;) =&gt; &#123;name: &#x27;fufu&#x27;&#125;</span><br><span class="line">// 测试发现对于对象来说delete和Vue.delete是没有任何区别的</span><br></pre></td></tr></table></figure></li>
</ol>
<p>delete只是被删除的元素变成了 empty&#x2F;undefined 其他的元素的键值还是不变。数组长度也不变。（逻辑删）<br>Vue.delete是直接删除该元素，长度发生变化。（物理删）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">2</span>]  <span class="comment">//[1,2,empty,4,5]</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">delete</span> arr[<span class="number">2</span>]  <span class="comment">//[1,2,4,5]</span></span><br></pre></td></tr></table></figure>

<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ol>
<li><p>事件捕获，事件冒泡<br>事件：事件是指文档和浏览器窗口发生特定交互的瞬间。<br>事件流： 事件流指页面中接受事件的顺序，微软为事件冒泡，网景为事件捕获。<br>事件捕获：由上而下，根元素最早接受事件，目标元素最后接受事件。<br>事件冒泡：由下而上，目标元素最早接受事件，逐级向上，最后根元素接受事件。<br>————————————————</p>
</li>
<li><p>DOM事件流**<br>DOM事件流规定，事件流由三个部分构成 事件捕获——目标阶段——事件冒泡，首先事件捕获为截获事件提供机会，然后实际目标接受事件，事件冒泡阶段对事件做出响应。事件在目标阶段是无法获取事件的。</p>
</li>
</ol>
<p>  ————————————————</p>
<ol start="3">
<li><p>. 事件处理程序<br>DOM事件定义了两种方法，addEventListener和removeEventListener他们都包含三个参数（1.处理事件的的方式click…2.事件处理函数（如果是删除函数必须是命名函数3.bool值为true为事件捕获阶段调用，默认为false事件冒泡阶段调用）<br>————————————————</p>
</li>
<li><p><strong>事件委托</strong></p>
</li>
</ol>
<p>它是通过事件冒泡，把子级事件委托给父级，将子级触发的事件绑定在父级身上</p>
<ul>
<li><p>减少多次绑定，提高程序性能</p>
</li>
<li><p>动态添加的子元素也能自动获取事件</p>
</li>
</ul>
<p> 5.<strong>js阻止事件冒泡和默认事件</strong></p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol>
<li>指的是浏览器不能执行其他网站的脚本。它是由浏览器的<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTUlOTAlOEMlRTYlQkElOTAlRTclQUQlOTYlRTclOTUlQTUmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">同源策略</span>造成的，是浏览器对javascript施加的安全限制。<br>• 同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域；</li>
<li>同源限制策略就是限制了一下几种行为：<br>1.Cookie、LocalStorage 和 IndexDB 无法读取<br>2.DOM 和 Js对象无法获得<br>3.AJAX 请求不能发送</li>
</ol>
<p>一、 通过jsonp跨域<br>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。通过script标签的src属性，请求跨域的数据接口，并通过函数调用的形式，接受跨域接口响应回来的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://test.com/data. php?callback=dosomething&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">//向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数</span></span><br><span class="line"><span class="comment">//处理服务器返回回调函数的数据</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">function</span> <span class="title function_">dosomething</span>(<span class="params">res</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="comment">//处理获得的数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>vue.js解决方案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">jsonp</span>(‘<span class="attr">http</span>:<span class="comment">//www.domain2.com:8080/login’, &#123;</span></span><br><span class="line"><span class="attr">params</span>: &#123;&#125;,</span><br><span class="line"><span class="attr">jsonp</span>: ‘handleCallback’</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>————————————————<br>二,反向代理： 在脚手架启动项目的时候，会顺便启动一个本地的后台服务，他的地址和前端的服务地址是一直的，那我们可以通过前端服务，请求自己的本地后台服务，再由自己的本地后台服务，去请求真实的服务，从而解决跨域，服务和服务之间是不存在跨域的，扮演了了一个中间代理的角色，从而在前端解决了跨域问题；</p>
<ol>
<li><p>在**<code>vue-cli脚手架环境</code><strong>下开发启动服务时，我们访问接口所遇到的跨域问题，vue-cli为我们在本地</strong><code>开启了一个服务</code><strong>,可以通过这个服务帮我们</strong><code>代理请求</code>**,解决跨域问题</p>
</li>
<li><p>在vue.config.js中，有我们需要的代理选项</p>
</li>
<li><pre><code class="js">// 配置反向代理
   proxy: &#123;
     // 当地址中有/api的时候会触发代理机制
     &#39;/api&#39;: &#123;
       target: &#39;http://ihrm-java.itheima.net/&#39;, // 要代理的真实服务器地址，这不用写api
       changOrigin: true // 是否跨域 只有为 true才会开启跨域
       // 代理完毕之后的真实服务地址会变成: http://ihrm-java.itheima . net/api,
       // 这里为什么要注释掉路径重写?L/是因为咋们的后台服务地址正好要求有这个api,所以不需要重写
   
       // 重写路径
       // pathRewrite:&#123;&#39;^/api&#39;&#125;
     &#125;
   &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   原理：vue前端启动locahost:8080，vue-cli会启动一个本地后端服务locahost:8080 这两者之间是没有跨域问题的，那我们的后端服务去请求后端接口的时候是，没有跨域问题的。只有前后端才会有跨域问题</span><br><span class="line"></span><br><span class="line">## css的选择器有那些？</span><br><span class="line"></span><br><span class="line">![css](D:\css.png)</span><br><span class="line"></span><br><span class="line">## 动态伪类：针对所有标签都适用的样式</span><br><span class="line"></span><br><span class="line">- **`:hover`** “悬停”：鼠标放到标签上的时候</span><br><span class="line">- **`:active`** “激活”： 鼠标点击标签，但是不松手时。</span><br><span class="line">- **`:focus`** 是某个标签获得焦点时的样式（比如某个输入框获得焦点）</span><br><span class="line"></span><br><span class="line">**静态伪类：只能用于超链接的样式**</span><br><span class="line"></span><br><span class="line">- **`:link`** 超链接点击之前</span><br><span class="line">- **`:visited`** 链接被访问过之后</span><br><span class="line"></span><br><span class="line">## es6中的箭头函数和普通函数的区别是什么？</span><br><span class="line"></span><br><span class="line">`this指向`   普通函数指向的是window或者他的调用者 箭头函数 沿用他上一层作用域的this指向</span><br><span class="line"></span><br><span class="line">箭头函数不能用作构造函数（不能使用new）,没有原型对象prototype，没有argments对象（可以用...arr来取代）</span><br><span class="line"></span><br><span class="line">## 数组去重的方法有哪些？</span><br><span class="line"></span><br><span class="line">1. ES6的set方法，它类似于数组，但是成员的值都是唯一的，没有重复的值</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   function unique(array)&#123;</span><br><span class="line">      return Array.from(new Set(array));     // Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例</span><br><span class="line">   &#125;</span><br><span class="line">   // 或者写成（建议写法）</span><br><span class="line">   const unique = arr =&gt; [...new Set(arr)] </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>双重循环 + <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1zcGxpY2Umc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">splice</span> （返回修改后的参数数组）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">双重循环，第一层循环，所有数据，第二层循环，从第一层循环的下标开始，向后循环，遇到重复的选项，则直接用splice删除相应的选项，最终返回去重后的数组</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">norepeat</span>(<span class="params">arr</span>)&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;arr.<span class="property">length</span>;)&#123;    <span class="comment">// 将当前选项与之后选项作对比，删除重复的</span></span><br><span class="line">          <span class="keyword">if</span>(arr[i]==arr[j])&#123;</span><br><span class="line">              arr.<span class="title function_">splice</span>(j,<span class="number">1</span>);</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="number">11</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> arr1=<span class="title function_">norepeat</span>(arr2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// 11 6 5 4 8 1 15</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sort排序后循环数组 + 相领元素比较</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">先将原数组排序,再把每一项与前一位比较，相同则删除，同时i不增加，否则i++</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">　　<span class="keyword">var</span> arr2 = arr.<span class="title function_">sort</span>();</span><br><span class="line">　　<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr2.<span class="property">length</span>;)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span>(arr2[i] === arr2[i-<span class="number">1</span>])&#123;</span><br><span class="line">　　　　　　arr2.<span class="title function_">splice</span>(i,<span class="number">1</span>);       </span><br><span class="line">　　　　&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           i++;</span><br><span class="line">        &#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> arr2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.利用判断对象属性是否存在的方法 + 新数组 —— <code>推荐！！！</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用对象属性存在的特性，如果没有该属性则存入新数组。</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">unique3</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj=&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> newArr=[]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">            obj[arr[i]] = <span class="number">1</span></span><br><span class="line">            newArr.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique2</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]));</span><br><span class="line"><span class="comment">// 结果是[1, 2, 3, 5, 6, 7, 4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="你都封装过哪些公共组件？举个例子"><a href="#你都封装过哪些公共组件？举个例子" class="headerlink" title="你都封装过哪些公共组件？举个例子"></a>你都封装过哪些公共组件？举个例子</h2><p> 我用vue开发的所有项目，都是采用组件化的思想开发的。一般我在搭建项目的时候，会创建一个views目录和一个commen目录,一个feature目录，views目录中放页面级的组件，commen中放公共组件（如：head（公共头组件），foot（公共底部组件）等），feature目录内放功能组件（如：swiper(轮播功能组件)，tabbar(切换功能组件)、list(上拉加载更多功能组件)）</p>
<p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性低等问题。</p>
<p>使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。但是我们一般用脚手架开发项目，每个 .vue单文件就是一个组件。在另一组件import 导入，并在components中注册，子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p>
<ol>
<li>上传图片公共组件</li>
<li>Excel文件上传组件</li>
</ol>
<h2 id="你为vue项目做过哪些性能优化？"><a href="#你为vue项目做过哪些性能优化？" class="headerlink" title="你为vue项目做过哪些性能优化？"></a>你为vue项目做过哪些性能优化？</h2><ul>
<li>使用cdn加载第三方模块</li>
<li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li>
<li>压缩代码</li>
<li>打包优化</li>
<li>第三方模块按需导入</li>
<li>图片懒加载</li>
<li>在更多的情况下，使用v-if替代v-show</li>
<li>SPA 页面采用keep-alive缓存组件</li>
<li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher </li>
<li>v-if和v-for不能连用 如果需要使用</li>
<li>v-for给每项元素绑定事件时使用事件代理</li>
<li>使用路由懒加载、异步组件 </li>
<li>防抖、节流</li>
</ul>
<h2 id="http和https协议有什么区别？除了这两个，还有其他协议吗？"><a href="#http和https协议有什么区别？除了这两个，还有其他协议吗？" class="headerlink" title="http和https协议有什么区别？除了这两个，还有其他协议吗？"></a>http和https协议有什么区别？除了这两个，还有其他协议吗？</h2><p>1、”http”和”https”都是超文本传输协议，但不同的是”https”是加安全协议，所以跟多用于敏感的通信，比如交易场景。</p>
<p>2、https主要由两部分组成：http+ SSL &#x2F; TLS，也就是在 http上又加了一层处理加密信息的模块。</p>
<p>3、https协议是由SSL+http构建的可进行加密传输、身份认证的网络协议，要比 http安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</p>
<p>https到 https的转向可以帮助企业网提升用 户访问安全水平，特别是对于有敏感信息保存和提供金融交易等服务的企业更有帮助。</p>
<h2 id="keep-alive-组件缓从"><a href="#keep-alive-组件缓从" class="headerlink" title="keep-alive-组件缓从"></a>keep-alive-组件缓从</h2><p>keep-alive 是 Vue 内置的一个抽象组件，它自身不会渲染一个DOM元素；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。可以使被包含的组件保留状态，或避免重新渲染 。也就是所谓的组件缓存；</p>
<p>使用keep-alive组件保留了组件状态且不会重新渲染，这样会导致created(){ } 钩子函数不会再次触发；</p>
<p>keep-alive不仅仅能保存页面 &#x2F; 组件的状态这么简单，还可以避免组件反复创建和渲染，有效提升系统性能。</p>
<h2 id="vue父子之间的传值"><a href="#vue父子之间的传值" class="headerlink" title="vue父子之间的传值?"></a>vue父子之间的传值?</h2><p>1、父组件向子组件传递数据<br>父组件内设置要传的数据，在父组件中引用的子组件上绑定一个自定义属性并把数据绑定在自定义属性上，在子组件添加参数props接收即可</p>
<p>2、子组件向父组件传递数据<br>子组件通过vue实例方法$emit进行触发并且可以携带参数，父组件监听使用@(v-on)进行监听，然后进行方法处理</p>
<p>3、非父子组件之间传递数据</p>
<p>3.1引入第三方new vue定义为eventBus<br>3.2)在组件中created中订阅方法eventBus.$on(“自定义事件名”,methods中的方法名)<br>3.3)在另一个兄弟组件中的methods中写函数，在函数中发布eventBus订阅的方法eventBus.Semit(“自定义事件名’)<br>3.4)在组件的template中绑定事件(比如click)</p>
<h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><p>Canvas介绍<br>1.canvas是html5的一个新标签，属于h5的新特性<br>2.canvas标签是一个图形的容器，简单点说就是一块画布，你可以在上画矩形，圆形，三角形，折线等等,也可以用来画logo<br>3.它是通过javascript来画的，即脚本绘制图形</p>
<p>canvas可以用来干啥呢？<br>1.制作web网页游戏（但是如果代码写的不咋的游戏可能会非常卡）<br>2.数据可视化（这么说你可能不明白，但我告诉你echarts就是基于canvas）<br>3.广告banner的动态效果非常适合用canvas制作<br>4.canvas还可以用来内嵌一些网页</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload=<span class="string">&quot;draw()&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 获取画布</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (canvas.<span class="property">getContext</span>) &#123; <span class="comment">// 用于验证浏览器是否支持canvas,它是h5的新特性，老版本ie不支持</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); <span class="comment">// 可选2d和3d</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(200, 0, 0, 1)&quot;</span>; <span class="comment">// 填充色</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            ctx.<span class="property">fillRect</span> (<span class="number">10</span>, <span class="number">10</span>, <span class="number">55</span>, <span class="number">50</span>); <span class="comment">// 画矩形的方法，四个参数含义，前两个表示x,y坐标（相对于canvas的位置，并不是相对于窗口），从哪里开始画，后面表示长宽。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0, 0, 200, 0.5)&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            ctx.<span class="property">fillRect</span> (<span class="number">30</span>, <span class="number">30</span>, <span class="number">55</span>, <span class="number">50</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">// 绘制一个矩形,清除特定矩形，绘制边框</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            ctx.<span class="title function_">fillRect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            ctx.<span class="title function_">clearRect</span>(<span class="number">112.5</span>, <span class="number">112.5</span>, <span class="number">75</span>, <span class="number">75</span>); <span class="comment">// 清除矩形</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            ctx.<span class="title function_">strokeRect</span>(<span class="number">125</span>, <span class="number">125</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 矩形边框</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="简述vue等单页面应用及优缺点"><a href="#简述vue等单页面应用及优缺点" class="headerlink" title="简述vue等单页面应用及优缺点"></a>简述vue等单页面应用及优缺点</h2><p>什么是SPA</p>
<blockquote>
<p><code>SPA</code> 全称 <code>Single Page Application</code>，即单页面应用。一般也称为 <strong>CSR</strong>（Client Side Render），即客户端渲染。它所需的资源，如 HTML、CSS 和 JS 等，在一次请求中就加载完成，也就是不需刷新地动态加载。浏览器(Client)渲染顾名思义就是所有的页面渲染、逻辑处理、页面路由、接口请求均是在浏览器中发生。对于 SPA 来说，页面的切换就是组件或视图之间的切换。</p>
<p>简单来说**,SPA应用程序只有一个html文件,在vue中可以通过<code>vue-router</code>来局部切换组件,而非刷新整个页面,来实现无刷新切换页面的技术**</p>
<p>SPA应用程序避免了由于在服务器上呈现页面而导致的中断。 这消除了 Web 开发世界在提供无缝用户体验方面通常面临的最大问题。</p>
<h4 id="优点-切换页面快，用户体验好"><a href="#优点-切换页面快，用户体验好" class="headerlink" title="优点 :切换页面快，用户体验好"></a>优点 :切换页面快，用户体验好</h4><p>页面每次切换跳转时，并不需要做<code>html</code>文件的请求，这样就节约了很多<code>http</code>发送时延，我们在切换页面的时候速度很快。</p>
<p>页面片段间的切换快，包括移动设备, 尤其是在网络环境差的时候, 因为组件已经预先加载好了, 并不需要发送网络请求, 所以用户体验好</p>
<h4 id="缺点：首次加载较慢，SEO优化差"><a href="#缺点：首次加载较慢，SEO优化差" class="headerlink" title="缺点：首次加载较慢，SEO优化差"></a>缺点：首次加载较慢，SEO优化差</h4><p>首屏时需要请求一次<code>html</code>，同时还要发送一次<code>js</code>请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。</p>
<p>SEO效果差，因为搜索引擎只认识<code>html</code>里的内容，不认识<code>js</code>的内容，而单页应用的内容都是靠<code>js</code>渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致SPA应用做出来的网页在百度和谷歌上的排名差</p>
</blockquote>
<h2 id="虚拟dom和真实的dom在生命周期的哪个地方"><a href="#虚拟dom和真实的dom在生命周期的哪个地方" class="headerlink" title="虚拟dom和真实的dom在生命周期的哪个地方"></a>虚拟dom和真实的dom在生命周期的哪个地方</h2><blockquote>
<p>虚拟DOM简单来说就是一个JS对象，用来描述文本中DOM的一些信息，当页面发生变化的时候，会使用到虚拟DOM,暂且叫它Vnode。当页面渲染的时候也会产生一份新的Vnode,暂且叫它是OldVnode，页面中数据更新的时候，新旧两份虚拟DOM会进行对比，通过Diff算法，生成一份新的的虚拟DOM，然后把他渲染到页面上去，节省了性能，这也是Vue的优点，能够操作JS对象来达到页面的更新，脱离了直接操作DOM，大大提升了性能，以及开发成本</p>
<p>mounted (挂载后)：在挂载完成之后被调用，执行render函数生成虚拟dom，创建真实dom替换虚拟dom，并挂载到实例。可以操作dom，比如事件监听</p>
</blockquote>
<h2 id="vue生命周期中父子组件的渲染顺序"><a href="#vue生命周期中父子组件的渲染顺序" class="headerlink" title="vue生命周期中父子组件的渲染顺序"></a>vue生命周期中父子组件的渲染顺序</h2><blockquote>
<p>在正常开发，挂载周期的执行顺序为：</p>
<p>父beforeCreate &#x3D;&gt; 父created &#x3D;&gt; 父beforeMount &#x3D;&gt; 子beforeCreate &#x3D;&gt; 子created &#x3D;&gt; 子beforeMount &#x3D;&gt; 子mounted &#x3D;&gt; 父mounted</p>
<p>在数据更新阶段执行顺序为：</p>
<p>父beforeUpdate &#x3D;&gt; 子beforeUpdate &#x3D;&gt; 子updated &#x3D;&gt; 父updated</p>
<p>在组件销毁阶段执行顺序为：</p>
<p>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</p>
<p>由此可见，其实所有周期规律就是：只要子组件被引入触发，所处不管任何周期都是父组件先开始执行，然后等到子组件执行完，父组件收尾。</p>
</blockquote>
<h2 id="vue中怎么去监听数据的变换"><a href="#vue中怎么去监听数据的变换" class="headerlink" title="vue中怎么去监听数据的变换"></a>vue中怎么去监听数据的变换</h2><blockquote>
<p>watch:使用这个 属性，可以监视 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数</p>
<p>computed:计算属性</p>
<p><strong>注意1：</strong> 计算属性，在引用的时候，一定不要加 () 去调用，直接把它当作普通 属性去使用就好了；<br><strong>注意2：</strong> 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化，就会立即重新计算 这个 计算属性的值</p>
<p><strong>注意3：</strong> 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所有的任何数据，都没有发生过变化，则不会重新对计算属性求值；</p>
</blockquote>
<h2 id="jquery和vue这两个框架有什么区别"><a href="#jquery和vue这两个框架有什么区别" class="headerlink" title="jquery和vue这两个框架有什么区别"></a>jquery和vue这两个框架有什么区别</h2><blockquote>
<p>从定义来看：</p>
<p>库是集合了某些对象、方法和函数的工具箱，用于解决具体问题或者满足特定范围的开发，我们只要清楚工具箱的使用方式，就可以调用工具箱的工具完成操作。</p>
<p>框架是一套架构和方法论，涵盖了整个开发过程的方方面面，是一个完整的开发解决方案，它的范围覆盖了库。</p>
<p>从使用来看：</p>
<p>两者有完全不同的用法。对于库，我们是写代码，调用了库的方法，完成某个操作。对于框架，我们是写代码，放在了框架里面，框架执行了代码，完成某个操作。</p>
</blockquote>
<h2 id="watch和computed的区别"><a href="#watch和computed的区别" class="headerlink" title="watch和computed的区别"></a>watch和computed的区别</h2><blockquote>
<p>watch、computed和methods之间的对比<br>computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；<br>methods方法表示一个具体的操作，主要书写业务逻辑；<br>watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体；</p>
</blockquote>
<h2 id="为什么组件中的data是个函数"><a href="#为什么组件中的data是个函数" class="headerlink" title="为什么组件中的data是个函数"></a>为什么组件中的data是个函数</h2><blockquote>
<p>在Vue实例中，data可以是一个对象也可以是一个函数 ,但是在组件中使用回直接报错。</p>
<p>我们都知道对象是一个引用数据类型，当多次使用同一个组件时，实际上引用的是同一个地址，这样一旦某一个组件数据发生更改，那么会直接影响到其他组件数据，不利于组件的复用，而函数形式则可以避免这种现象的发生，函数中每一次都会返回一个全新的对象，这样多次<br>产生这样的原因这是两者共用了同一个内存地址，a修改的内容，同样对b产生了影响</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; <span class="comment">//data可以是一个对象 </span></span><br><span class="line">&gt;<span class="attr">data</span>:&#123; 	<span class="attr">messsage</span>:<span class="string">&quot;hello world&quot;</span> &#125;， </span><br><span class="line">&gt;<span class="comment">//data也可以是一个函数 </span></span><br><span class="line">&gt;<span class="title function_">data</span>(<span class="params"></span>)&#123; 	</span><br><span class="line"><span class="keyword">return</span> &#123; 		</span><br><span class="line"><span class="attr">message</span>:<span class="string">&quot;hello world&quot;</span> </span><br><span class="line">&#125; </span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="路由的两种路由模式，说一下你对这两种路由的理解"><a href="#路由的两种路由模式，说一下你对这两种路由的理解" class="headerlink" title="路由的两种路由模式，说一下你对这两种路由的理解"></a>路由的两种路由模式，说一下你对这两种路由的理解</h2><blockquote>
<p>路由器分别有两种模式,一种是<code>hash</code>模式,另一种是<code>history</code>模式,在使用<code>vue-cli</code>以及<code>vue-router</code>默认搭建的<code>vue</code>项目,如果不做特殊的配置,默认就是<code>hash</code>模式</p>
<p><strong>哈希模式(hash)</strong></p>
<p><code>vue-router</code>默认<code>hash</code>模式,使用<code>url</code>的哈希(<code>hash</code>)来模拟一个完整的<code>URL</code>,当<code>URL</code>改变时,页面不会重新加载</p>
<p><code>http://localhost/#home</code></p>
<p><strong>特点</strong>: <code>#</code>号后面的参数不会传送给服务器,兼容性好,不会作为路径的一部分发送给服务器,也就是它不会包括在<code>HTTP</code>请求体中,对后端完全没有影响,只是我们前端同学自己玩</p>
<p>页面刷新时,会停留在当前页面,不会重新加载</p>
<p>如果觉得<code>hash</code>路径很丑,不简洁,我们可以用路由的<code>history</code>模式,这种模式充分利用<code>history.pushState API</code>          或<code>replaceState</code>,来完成,<code>url</code>跳转而无需重新加载页面</p>
<p><strong>历史模式</strong></p>
<p><code>history</code>模式:在实例化配置对象中添加<code>mode</code>模式,值为<code>history</code>就可以了的 经过改造后,<code>hash</code>模式就会变成<code>history</code>模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">&gt;<span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">&gt;<span class="attr">routes</span>: [...]</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure>

<p>这两种方式的使用都是没啥问题的,如果你在意浏览器<code>url</code>的颜值,<code>#</code>符号掺杂在<code>url</code>里看起来确实有些不优雅</p>
<p>如果你想<code>url</code>更好看,那么就使用<code>history</code>模式</p>
<p>但是:在<code>hash</code>模式下,使用<code>hash</code>符号之前的内容会被包含在请求体中,<code>#</code>号后面的不会发送给服务器</p>
<p>而<code>history</code>模式下,前端的<code>URL</code>必须和实际向后端发起请求的<code>URL</code>保持一致</p>
<p>如:<code>https://itclan.cn/fontend/id</code>,如果后端缺少没有对<code>/fontend/id</code>的路由处理,那么它将返回<code>404</code>错误</p>
<p>如果你想要支持<code>history</code>模式,那么需要后端同学支持,想要彻底解决404的问题,需要与后端同学协商,<strong>因为需要后端与前端路由做匹配</strong></p>
<p>在服务端增加一个覆盖所有情况的时候的候选资源,如果<code>url</code>匹配不到任何静态资源,应该返回一个首页页面</p>
<p>如果出现404,容易让用户觉得这是一个Bug</p>
</blockquote>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>前端路由,有两种模式,一种是<code>hash</code>模式,另一种是<code>history</code>模式,其中<code>hash</code>模式是默认模式,<code>#</code>后面的不会发送给服务端,不会重新刷新加载页面,而<code>history</code>模式,<code>url</code>虽然比较好看,但是想要完整支持,需要后端同学提供支持,后端路由与前端的路由需要做匹配</p>
<p>否则部署到线上,一刷新页面,会出现<code>404</code>的问题</p>
<h2 id="如何解决前台刷新页面404问题"><a href="#如何解决前台刷新页面404问题" class="headerlink" title="如何解决前台刷新页面404问题"></a>如何解决前台刷新页面404问题</h2><blockquote>
<p>解决这个问题:如果你用的是<code>Node</code>做后端服务,那么在<code>Node</code>后台中可以加入一个中间件比如：<code>connect-history-api-fallback</code>即可解决这种404问题</p>
<p>如果是<code>java</code>或<code>php</code>,找后端同学,让后端路由与前端路由做匹配,或是用<code>Ngnix</code>做中间代理.</p>
</blockquote>
<h2 id="你们的项目是如何进行打包上线的？"><a href="#你们的项目是如何进行打包上线的？" class="headerlink" title="你们的项目是如何进行打包上线的？"></a>你们的项目是如何进行打包上线的？</h2><p>话术：</p>
<ol>
<li>一般如果要打包的话，可以调用npm run build:prod 进行打包，脚手架会将打包后的文件放入dist目录下，然后直接把dist目录部署到服务器即可。</li>
<li>这个过程一般都是项目组长完成的，我一般参与的比较少，但是也了解了一些过程，大概有这么几个方面</li>
<li>我们在上线之前，会把路由hash模式改成history模式，这样路径会比较好看一些。路由router对象有一个属性叫mode，把值改成history就可以了</li>
<li>我们会用脚手架自带的工具分析一下目前项目的整体性能，命令是npm run preview, 可以筛选出整个项目中体积比较大的js和css文件，比如element.js, vue.js,echarts.js等等</li>
<li>这些文件可以考虑使用cdn来提高性能，降低服务器的压力，这个过程需要在vue.config.js中做一些配置，细节记不清了，不过大概思路就是：让脚手架打包的时候把那些比较大的js排除掉，然后在index.html引入这些css和js的cdn路径</li>
<li>不过以上过程只有在生产模式下需要处理，开发模式一下不用变，所以需要在vue.config.js中做好判断</li>
<li>另外，发布阶段，有时候可能因为没有通过eslint语法校验，导致打包不成功，此时可以修改代码，让代码通过eslint校验。如果代码修改工作量太大，也可以考虑修改eslint的配置文件，调整校验规则，配置文件的名字叫eslintrc.js</li>
<li>代码中在开发的时候有很多console.log的日志，这些在上线的时候已经没有必要了，甚至可能影响网站的安全，可以配置脚手架，在打包的时候自动移出log日志。具体可以使用一个webpack插件，叫做babel-plugin-transform-remove-console，当然，添加这个插件前也要判断是否是生产模式，只有生产模式才添加这个插件</li>
<li>我们的代码在服务器的部署是后端人员来做的，开发阶段，我通过proxy反向代理来跨域，打包的时候就不需要了，由后端修改nginx服务器的配置来实现跨域。另外，我的路由如果是history模式，也需要修改一些nginx的配置，否则可能出现404页面，具体配置我没做过，也不太了解了</li>
<li>我能想到的就是这些，其他的就没有了</li>
</ol>
<h2 id="获取vue的原生-DOM"><a href="#获取vue的原生-DOM" class="headerlink" title="获取vue的原生 DOM"></a>获取vue的原生 DOM</h2><p>通过ref  或者是 ID</p>
<p>获取组件对象 也可以通过ref ，然后调用$refs ,可以拿到组件实例，这样就可以调用子组件的方法了</p>
<h2 id="webpack的常见配置都有哪些？"><a href="#webpack的常见配置都有哪些？" class="headerlink" title="webpack的常见配置都有哪些？"></a>webpack的常见配置都有哪些？</h2><p>话术：</p>
<ol>
<li>平时都使用脚手架默认的配置，就可以完成大部分的开发需求，一般不怎么单独配置</li>
<li>不过我自己看过一点配置，比如用entry指定打包的入口文件；用output指定打包的出口文件；配置各种loaders，来加载不同类型的文件，比如vue-loader用来加载.vue类型的文件，css-loader用来加载css文件，less-loader用来加载less文件，scss-loader加载scss文件，file-loader用来加载图片和字体文件等等</li>
<li>另外，我还了解过一点webpack的常用插件，比如webpack-dev-server, 是一个轻量级的服务器，修改文件源码后，自动刷新页面将修改同步到页面上，脚手架已经内置了，我们不用单独配置；html-webpack-plugin，用来根据html模板生成html页面，一般脚手架也会内置，我们不用管了</li>
<li>大概就了解这些了</li>
</ol>
<h2 id="你们是如何和美工沟通交流的"><a href="#你们是如何和美工沟通交流的" class="headerlink" title="你们是如何和美工沟通交流的"></a>你们是如何和美工沟通交流的</h2><ol>
<li><p>使用<strong>蓝湖</strong>进行沟通交流    <span class="exturl" data-url="aHR0cHM6Ly9sYW5odWFwcC5jb20vd2ViLyMvaXRlbQ==">https://lanhuapp.com/web/#/item</span></p>
<p>蓝湖类似在线版的<strong>像素大厨</strong></p>
<p>蓝湖的基本使用流程是这样的：</p>
<ol>
<li>美工先使用ps设计视觉稿</li>
<li>美工将psd文件上传蓝湖，蓝湖可以自动识别设计稿文件</li>
<li>开发人员进入蓝湖，可以看到视觉稿，能够看到标记的尺寸，颜色等，也能直接下载切图</li>
</ol>
</li>
<li><p>不使用蓝湖进行沟通交流</p>
<ol>
<li>美工先使用ps设计视觉稿</li>
<li>美工在直接把psd原始文件扔给开发，同时也会把图切好，打包发给开发</li>
<li>开发用像素大厨打开psd文件，查看尺寸，颜色等，切图直接拿过来使用即可</li>
</ol>
</li>
</ol>
<h2 id="如何实现excel文件的导入和导出？"><a href="#如何实现excel文件的导入和导出？" class="headerlink" title="如何实现excel文件的导入和导出？"></a>如何实现excel文件的导入和导出？</h2><ol>
<li>我们使用xlsx这样一个第三方的包，来实现excel导入和导出的</li>
<li>首先说一下导入：页面上会设置一个上传excel文件的按钮，用户点击按钮，选择文件并上传，我可以读取到上传文件的原始内容，调用xlsx提供的read方法，读取文件内容，可以返回一个工作簿对象，通过这个对象可以拿到excel文件的工作表，工作表的表头信息和内容信息，然后我将这些内容信息整理成一个数组，调用后端接口，传递给后端，从而完成了文件的导入</li>
<li>再说一下导出：仍然使用xlsx这样的包，核心是调用write方法实现excel的导出。首先，我使用了一个已经封装好的Export2Excel.js的工具模块，这个模块底层就是用的xlsx的write方法实现的，这个模块暴露了一个些方法，方便实现文件导出。我先从data中取出要导出的数组对象，然后调用这个模块的export_json_to_excel方法，传入数组对象，文件名称，文件类型，表头等信息，这个方法内部会实现导出，并触发浏览器的下载，将文件下载到本地</li>
<li>如果面试官继续问细节，就可以说自己记不太清楚了</li>
</ol>
<h2 id="怎么理解vue响应式数据的原理或者是双向数据绑定原理"><a href="#怎么理解vue响应式数据的原理或者是双向数据绑定原理" class="headerlink" title="怎么理解vue响应式数据的原理或者是双向数据绑定原理"></a>怎么理解vue响应式数据的原理或者是双向数据绑定原理</h2><blockquote>
<ol>
<li><p>Vue中数据双向绑定主要是指<strong>当数据发生变化时，视图发生变化；当视图发生变化时，数据也发生响应的变化</strong>。其中视图发生变化时，数据发生相应的变化，可以用事件绑定来实现</p>
<p><strong>原理</strong></p>
</li>
<li><p>一个Vue实例在初始化数据时，监听器Observer会调用Object.defineProperty对该Vue实例中data选项的全部属性（包括属性对象的子属性），添加上getter和setter方法，并对每个属性添加一个订阅器Dep，用于存储监听该属性值变化的订阅者Watcher，当属性值发生变化时，该属性值中的订阅器Dep会通知其订阅者数组，订阅者会调用先前在根据指令绑定在对应节点的更新函数更新页面，从而致使它关联的组件得以更新。</p>
</li>
</ol>
</blockquote>
<h2 id="v-for-和v-if那个先执行？"><a href="#v-for-和v-if那个先执行？" class="headerlink" title="v-for 和v-if那个先执行？"></a>v-for 和v-if那个先执行？</h2><ol>
<li>实践中<strong>不应该把v-for和v-if放一起</strong></li>
<li>在<strong>vue2中</strong>，<strong>v-for的优先级是高于v-if</strong>，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；</li>
<li>另外需要注意的是在<strong>vue3中则完全相反，v-if的优先级高于v-for</strong>，所以v-if执行时，它调用的变量还不存在，就会导致异常</li>
</ol>
<h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>diff算法就是用于比较新旧两个虚拟dom之间差异的一种算法</p>
<p>比较两个虚拟dom只会在同层级之间进行比较，不会跨层级进行比较。而用来判断是否是同层级的标准就是</p>
<ol>
<li>是否在同一层</li>
<li>是否有相同的父级</li>
</ol>
<p>比较两个节点是否是相同节点，判断是否是相同节点的条件是，key和sel（选择器）必须都相同，标签没有key怎么办啊，没有key那就是undefined，undefined &#x3D;&#x3D;&#x3D; undefined 始终为true，所以没有key只需要保证sel相同就行，如果不相同，那么执行替换操作，即新增新vnode上的元素，删除旧vnode上的元素 例如，原来是div，新vnode变成了p，那么就是新增p元素，再删除div元素。相当于就是p替换了div</p>
<h2 id="路由传参的方式？"><a href="#路由传参的方式？" class="headerlink" title="路由传参的方式？"></a>路由传参的方式？</h2><p><strong>路由的参数分为<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1wYXJhbXMmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">params</span>参数和query参数，而params传参又可分为在url地址栏中显示参数和不显示参数两种方式</strong></p>
<p><strong>params传参显示参数</strong></p>
<p>在路径中显示参数，在配置路由时，需要占位，地址栏表现为&#x2F;search&#x2F;123，刷新页面，参数还在</p>
<p>若要表示params参数可有可无，可在后面加上   ?</p>
<p><strong>params传参（不显示参数）</strong></p>
<p>在路径中不显示参数，在配置路由时，不需要占位，但是需要name,刷新页面，参数消失</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">path</span>: <span class="string">&#x27;/search&#x27;</span>,</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;search&#x27;</span>,</span><br></pre></td></tr></table></figure>

<p>声明式导航</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;name:&#x27;search&#x27;,params:&#123;keyword:123&#125;&#125;&quot;</span>&gt;搜索&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p>编程式导航</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">This</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>:&#123; <span class="attr">keyword</span>:<span class="number">123</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="C:\Users\m1769\AppData\Roaming\Typora\typora-user-images\image-20221105132050537.png" alt="image-20221105132050537"></p>
<h2 id="声明式导航和编程式导航的区别？"><a href="#声明式导航和编程式导航的区别？" class="headerlink" title="声明式导航和编程式导航的区别？"></a>声明式导航和编程式导航的区别？</h2><p>1.引入vue文件<br>2.导入路由  vue router<br>3.使用vue router插件，把它注册到全局 vue.use<br>4.创建路由规则数组<br>5.创建路由规则对象-传入规则，也就是传入第四步<br>6.然后就是默认导出<br>7.再到main.js里面默认导入<br>8.挂载到vue实例上面去<br>—还要到app文件里面使用router-view挂载点显示切换的路由</p>
<h3 id="1-声明式导航是直接渲染到页面的，比如a链接"><a href="#1-声明式导航是直接渲染到页面的，比如a链接" class="headerlink" title="1.声明式导航是直接渲染到页面的，比如a链接"></a>1.声明式导航是直接渲染到页面的，比如a链接</h3><p><code>&lt;router-link :to=&quot;/search/123&quot;&gt;搜索&lt;/router-link&gt;</code></p>
<h3 id="2-编程式导航则是用在js处理逻辑后需要页面跳转，比如点击button按钮跳转"><a href="#2-编程式导航则是用在js处理逻辑后需要页面跳转，比如点击button按钮跳转" class="headerlink" title="2.编程式导航则是用在js处理逻辑后需要页面跳转，比如点击button按钮跳转"></a>2.编程式导航则是用在js处理逻辑后需要页面跳转，比如点击button按钮跳转</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;path&#x27;</span>, <span class="attr">query</span>: &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>, <span class="attr">params</span>: &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="vue全局注册一个插件的方式"><a href="#vue全局注册一个插件的方式" class="headerlink" title="vue全局注册一个插件的方式"></a>vue全局注册一个插件的方式</h2><h3 id="采用vue-use-常用来注册生态类的插件-比如-vant-，element-ui-，-router，vuex"><a href="#采用vue-use-常用来注册生态类的插件-比如-vant-，element-ui-，-router，vuex" class="headerlink" title="采用vue.use 常用来注册生态类的插件  比如 vant ，element-ui ， router，vuex"></a>采用vue.use 常用来注册生态类的插件  比如 vant ，element-ui ， router，vuex</h3><h3 id="插件的全局注册-：-可以挂载到vue的原型上面-比如-：Vue-protype-http-x3D-axios，还有echacts-也一样"><a href="#插件的全局注册-：-可以挂载到vue的原型上面-比如-：Vue-protype-http-x3D-axios，还有echacts-也一样" class="headerlink" title="插件的全局注册 ： 可以挂载到vue的原型上面 比如 ：Vue.protype.$http &#x3D; axios，还有echacts  也一样"></a>插件的全局注册 ： 可以挂载到vue的原型上面 比如 ：Vue.protype.$http &#x3D; axios，还有echacts  也一样</h3><h3 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h3><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>就是在A网站登录过，进入B网站时能够自动识别我的登录状态，不在重复登录，主要逻辑在服务器端，与前端没多大关系。</p>
<h2 id="为什么使用scss"><a href="#为什么使用scss" class="headerlink" title="为什么使用scss"></a>为什么使用scss</h2><h3 id="1-易维护，更方便的定制"><a href="#1-易维护，更方便的定制" class="headerlink" title="1.易维护，更方便的定制,"></a>1.易维护，更方便的定制,</h3><h3 id="2-对于编程人员的友好"><a href="#2-对于编程人员的友好" class="headerlink" title="2.对于编程人员的友好,"></a>2.对于编程人员的友好,</h3><h3 id="3-效率的提升"><a href="#3-效率的提升" class="headerlink" title="3.效率的提升"></a>3.效率的提升</h3><h2 id="75-虚拟dom的优缺点"><a href="#75-虚拟dom的优缺点" class="headerlink" title="75.虚拟dom的优缺点"></a>75.虚拟dom的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p> 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</p>
<p>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</p>
<p>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</p>
<h2 id="for-in-和-for-of-的区别？"><a href="#for-in-和-for-of-的区别？" class="headerlink" title="for  in  和 for  of  的区别？"></a>for  in  和 for  of  的区别？</h2><p>区别一：for in 和 for of 都可以循环数组，for in 输出的是数组的index下标，而for of 输出的是数组的每一项的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// for ... in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// 输出 0,1,2,3</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// for ... of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// 输出 1,2,3,4</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>区别二：for in 可以遍历对象，for of 不能遍历对象，只能遍历带有iterator接口的，例如Set,Map,String,Array</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">name</span>: <span class="string">&#x27;lx&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;</span><br><span class="line">    <span class="comment">// for ... in</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// 输出 name,age</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(object[key]) <span class="comment">// 输出 lx,23</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// for ... of</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> object) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// 报错 Uncaught TypeError: object is not iterable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>数组对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [&#123; <span class="attr">name</span>: <span class="string">&#x27;lx&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">23</span> &#125;]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> list) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(val) <span class="comment">// 输出&#123; name: &#x27;lx&#x27; &#125;, &#123; age: 23 &#125;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> val) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(val[key]) <span class="comment">// 输出 lx,23</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结：for in适合遍历对象，for of适合遍历数组。for in遍历的是数组的索引，对象的属性，以及原型链上的属性。</p>
<h2 id="JS中0-1-0-2为什么不等于0-3"><a href="#JS中0-1-0-2为什么不等于0-3" class="headerlink" title="JS中0.1+0.2为什么不等于0.3"></a>JS中0.1+0.2为什么不等于0.3</h2><h3 id="在0-1与-0-2-相加的时候，会先转换为二进制，0-1与0-2转换为二进制的时候尾数会发生无限循环，然后进行对阶运算，js引擎对二进制进行截断，所以造成精度丢失；"><a href="#在0-1与-0-2-相加的时候，会先转换为二进制，0-1与0-2转换为二进制的时候尾数会发生无限循环，然后进行对阶运算，js引擎对二进制进行截断，所以造成精度丢失；" class="headerlink" title="在0.1与 0.2 相加的时候，会先转换为二进制，0.1与0.2转换为二进制的时候尾数会发生无限循环，然后进行对阶运算，js引擎对二进制进行截断，所以造成精度丢失；"></a>在<code>0.1</code>与 <code>0.2</code> 相加的时候，会先转换为<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTQlQkElOEMlRTglQkYlOUIlRTUlODglQjYmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">二进制</span>，<code>0.1</code>与<code>0.2</code>转换为二进制的时候尾数会发生无限循环，然后进行对阶运算，<code>js引擎</code>对二进制进行截断，所以造成精度丢失；</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0.1</span>*<span class="number">1000</span>+<span class="number">0.2</span>*<span class="number">1000</span>)/<span class="number">1000</span>==<span class="number">0.3</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">// 把计算数字 提升 10 的N次方 倍 再 除以 10的N次方。一般都用 1000 就行了</span></span><br></pre></td></tr></table></figure>

<h2 id="call-apply-bind的区别？"><a href="#call-apply-bind的区别？" class="headerlink" title="call ,apply ,bind的区别？"></a>call ,apply ,bind的区别？</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>作用相同 ，都是动态修改this指向，都不会修改原先函数的this指向</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>执行方式不同 ： call 和apply是改变之后页面加载之后就立刻执行，是同步代码 。</p>
<p>​								bind是异步代码改变后不会立刻执行而是返回一个新的函数，</p>
<p>传参方式不同： call bind 传参是一个一个的传入，不能使用剩余参数传参。</p>
<p>​								apply可以使用数组的方式传入的，只要是数组的方式就可以使用剩余参数的方式传入</p>
<h2 id="闭包的理解及使用场景"><a href="#闭包的理解及使用场景" class="headerlink" title="闭包的理解及使用场景"></a>闭包的理解及使用场景</h2><p>一个函数的<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTQlQkQlOUMlRTclOTQlQTglRTUlOUYlOUYmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">作用域</span>可以访问另一个函数的局部变量，这个变量所在的函数就是闭包函数</p>
<p>闭包使得内部函数可以访问外部函数的属性（变量或方法）</p>
<p>闭包的触发方式：</p>
<ol>
<li>函数作为参数被传递</li>
<li>函数作为返回值被返回</li>
</ol>
<p>闭包的应用场景：</p>
<p>​		将某一函数中的隐藏数据使用api提供给外界访问</p>
<h2 id="less的使用方式及优点？"><a href="#less的使用方式及优点？" class="headerlink" title="less的使用方式及优点？"></a>less的使用方式及优点？</h2><p>Less的优点：</p>
<p>1，LESS支持创建更清洁，跨浏览器友好的CSS更快更容易</p>
<p>2，LESS是用JavaScript设计的，并且创建在 live 中使用，其编译速度比其他CSS预处理器更快。</p>
<p>3，LESS保持你的代码以模块化的方式，这是非常重要的，通过使其可读性和容易改变。</p>
<p>4，可以通过使用LESS 变量来实现更快的维护。</p>
<p>5，更清晰和更可读的代码可以以有组织的方式编写。</p>
<p>6，我们可以定义样式，它可以在整个代码中重复使用。</p>
<p>7，LESS是基于JavaScript的，是超集的CSS。</p>
<p>8，LESS是一个敏捷工具，可以排除代码冗余的问题。<br><img data-src="https://img-blog.csdnimg.cn/c1f531ad615146db90f98cf6a0faa5bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Z2o6IOW5qmY77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="如何修改elment-ui组件的样式？"><a href="#如何修改elment-ui组件的样式？" class="headerlink" title="如何修改elment-ui组件的样式？"></a>如何修改elment-ui组件的样式？</h2><h3 id="1-新建全局样式表"><a href="#1-新建全局样式表" class="headerlink" title="1.新建全局样式表"></a>1.新建全局样式表</h3><p>新建global.css全局样式文件，并在main,js中进行引用</p>
<p>import ‘.&#x2F;style&#x2F;global.css’<br>在全局样式下的样式会覆盖vue中单页面中element-ui样式。</p>
<h3 id="2-在当前vue页面下新建style标签"><a href="#2-在当前vue页面下新建style标签" class="headerlink" title="2.在当前vue页面下新建style标签"></a>2.在当前vue页面下新建style标签</h3><p>在当前style下不要使用scoped属性，在写有scoped属性不会覆盖element-ui样式</p>
<h3 id="3-使用-x2F-deep-x2F-进行深度修改样式"><a href="#3-使用-x2F-deep-x2F-进行深度修改样式" class="headerlink" title="3.使用&#x2F;deep&#x2F;进行深度修改样式"></a>3.使用&#x2F;deep&#x2F;进行深度修改样式</h3><p>找到需要修改的样式的标签名的类名，在类名前加&#x2F;deep&#x2F;,这种方式可以强制修改element-ui样式，，可直接用到加了scoped属性的style节点下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改级联选择框的默认宽度</span></span><br><span class="line">/deep/ .<span class="property">el</span>-cascader &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-通过内联样式-或者-绑定样式覆盖默认样式"><a href="#4-通过内联样式-或者-绑定样式覆盖默认样式" class="headerlink" title="4.通过内联样式 或者 绑定样式覆盖默认样式"></a>4.通过内联样式 或者 绑定样式覆盖默认样式</h3><p>不是用通用  例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button :style=<span class="string">&quot;selfstyle&quot;</span>&gt;默认按钮&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>



   <script>
       export default {
         data() {
           return {
               selfstyle: {
                   color: "white",
           marginTop: "10px",
           width: "100px",
           backgroundColor: "cadetblue"
               }
           };
         }
       }
   </script>
<h2 id="ajax的执行机制？"><a href="#ajax的执行机制？" class="headerlink" title="ajax的执行机制？"></a>ajax的执行机制？</h2><p>1、创建 XMLHTTPRequest 对象,也就是创建一个异步调用对象. </p>
<p>2、创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息. </p>
<p>3、设置响应 HTTP 请求状态变化的函数. </p>
<p>4、发送 HTTP 请求.</p>
<p> 5、获取异步调用返回的数据. </p>
<p>6、使用 JavaScript 和 DOM 实现局部刷新. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="keyword">var</span> <span class="title class_">HTTPRequest</span>; <span class="keyword">function</span> <span class="title function_">checkUsername</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//创建 XMLHTTPRequest 对象</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">XMLHTTPRequest</span>) &#123;</span><br><span class="line">	<span class="comment">//在 IE6 以上的版本以及其他内核的浏览器(Mozilla)等</span></span><br><span class="line">		<span class="title class_">HTTPRequest</span> = <span class="keyword">new</span> <span class="title class_">XMLHTTPRequest</span>(); &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">ActiveXObject</span>) &#123;</span><br><span class="line">	<span class="comment">//在 IE6 以下的版本</span></span><br><span class="line">		<span class="title class_">HTTPRequest</span> = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(); &#125;</span><br><span class="line">	<span class="comment">//创建 HTTP 请求</span></span><br><span class="line">		<span class="title class_">HTTPRequest</span>.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;Servlet1&quot;</span>, <span class="literal">true</span>); <span class="comment">//因为我使用的是 post 方式，所以需要设置消息头</span></span><br><span class="line">		<span class="title class_">HTTPRequest</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>); <span class="comment">//指定回调函数</span></span><br><span class="line">		<span class="title class_">HTTPRequest</span>.<span class="property">onreadystatechange</span> = response22; <span class="comment">//得到文本框的数据</span></span><br><span class="line">		<span class="keyword">var</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>; <span class="comment">//发送 HTTP 请求，把要检测的用户名传递进去</span></span><br><span class="line">		<span class="title class_">HTTPRequest</span>.<span class="title function_">send</span>(<span class="string">&quot;username=&quot;</span> + name); &#125;</span><br><span class="line">	<span class="comment">//接收服务器响应数据</span></span><br><span class="line">		<span class="keyword">function</span> <span class="title function_">response22</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">//判断请求状态码是否是 4【数据接收完成】</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="title class_">HTTPRequest</span>.<span class="property">readyState</span>==<span class="number">4</span>) &#123;</span><br><span class="line">	<span class="comment">//再判断状态码是否为 200【200 是成功的】</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="title class_">HTTPRequest</span>.<span class="property">status</span>==<span class="number">200</span>) &#123;</span><br><span class="line">	<span class="comment">//得到服务端返回的文本数据</span></span><br><span class="line">		<span class="keyword">var</span> text = <span class="title class_">HTTPRequest</span>.<span class="property">responseText</span>; <span class="comment">//把服务端返回的数据写在 div 上</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>); div.<span class="property">innerText</span> = text; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<p><strong>未完：将持续更新…</strong></p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2022-12-08 19:39:08" itemprop="dateModified" datetime="2022-12-08T19:39:08+08:00">2022-12-08</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>zhixiong <i class="ic i-at"><em>@</em></i>Mondy
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2022/12/01/2022%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/" title="2022前端高频面试题">http://example.com/2022/12/01/2022前端高频面试题/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2022/09/18/%E9%99%8B%E5%AE%A4%E9%93%AD/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giph4wqtg4j20zk0m8x6p.jpg" title="陋室铭————刘禹锡">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>陋室铭————刘禹锡</h3>
  </a>

    </div>
    <div class="item right">
    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.</span> <span class="toc-text">Vue的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">GET请求和POST请求的区别是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5"><span class="toc-number">2.1.</span> <span class="toc-text">深入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BC%A9%E6%94%BE%E7%9A%84%E5%BB%B6%E8%BF%9F%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">移动端缩放的延迟？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%BB%B6%E8%BF%9F"><span class="toc-number">3.1.</span> <span class="toc-text">如何避免延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%9D%99%E6%AD%A2%E7%BC%A9%E6%94%BE"><span class="toc-number">3.2.</span> <span class="toc-text">方法一：静止缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9Afastclick-js"><span class="toc-number">3.3.</span> <span class="toc-text">方法二：fastclick.js</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E7%9A%84%E4%B8%89%E4%B8%AA%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">js的三个高阶函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8F%91%E5%BC%80%E5%8F%91%E5%92%8C%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">前端模块发开发和组件化开发的区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">组件化:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">模块化:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.</span> <span class="toc-text">区别:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="toc-number">5.4.</span> <span class="toc-text">好处：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%A4%84%E7%90%86%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">为什么要进行防抖和节流处理？如何实现防抖和节流？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.0.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.1.</span> <span class="toc-text">结合应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">为什么要用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96"><span class="toc-number">6.3.</span> <span class="toc-text">如何实现防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">如何实现节流？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-v-for%E5%90%8E%E9%9D%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0-key"><span class="toc-number">7.</span> <span class="toc-text">3. v-for后面为什么要加:key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-computed-%E5%92%8C-watch%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">4.computed 和 watch的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">promise有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9async%E5%92%8Cawait%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">谈谈对async和await的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#route%E5%92%8C-router%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">$route和$router的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">vue中的常用指令有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">什么是路由懒加载，为什么要使用路由懒加载？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4v-model%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">说说v-model的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">15.</span> <span class="toc-text">谈谈你对vue中的虚拟DOM的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">15.1.</span> <span class="toc-text">虚拟DOM中key的作用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9Fvuex%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">vuex是做什么的？vuex中有哪些属性，分别有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">17.</span> <span class="toc-text">深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D-%E5%B0%86%E5%8E%9F%E5%AF%B9%E8%B1%A1%E6%88%96%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B4%E6%8E%A5%E8%B5%8B%E7%BB%99%E6%96%B0%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%96%B0%E6%95%B0%E7%BB%84%EF%BC%8C%E6%96%B0%E5%AF%B9%E8%B1%A1-x2F-%E6%95%B0%E7%BB%84%E5%8F%AA%E6%98%AF%E5%8E%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E3%80%82"><span class="toc-number">17.1.</span> <span class="toc-text">浅拷贝:将原对象或原数组的引用直接赋给新对象，新数组，新对象&#x2F;数组只是原对象的一个引用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%8C%E5%B0%86%E5%8E%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E9%A1%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E2%80%9C%E5%80%BC%E2%80%9D-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0-%E6%8B%B7%E8%B4%9D%E8%BF%87%E6%9D%A5%EF%BC%8C%E6%98%AF%E2%80%9C%E5%80%BC%E2%80%9D%E8%80%8C%E4%B8%8D%E6%98%AF%E2%80%9C%E5%BC%95%E7%94%A8%E2%80%9D%E3%80%82"><span class="toc-number">17.2.</span> <span class="toc-text">深拷贝:创建一个新的对象和数组，将原对象的各项属性的“值”(数组的所有元素)拷贝过来，是“值”而不是“引用”。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">17.3.</span> <span class="toc-text">实现深拷贝的三种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VUE%E4%B8%AD-nextTick%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">18.</span> <span class="toc-text">VUE中$nextTick的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84-set%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">19.</span> <span class="toc-text">vue中的$set的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AEname%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">20.</span> <span class="toc-text">路由配置name属性是为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es6%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">es6的新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81"><span class="toc-number">22.</span> <span class="toc-text">什么是重绘和回流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">如何改变this指向？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">new操作符都干了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Bkeep-alive%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">25.</span> <span class="toc-text">请描述一下keep-alive的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E6%9C%89%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E8%AF%B7%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">26.</span> <span class="toc-text">vue自定义指令有用过吗？请举个例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E9%99%A4%E4%BA%86%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E9%BB%98%E8%AE%A4%E5%86%85%E7%BD%AE%E7%9A%84%E6%8C%87%E4%BB%A4-v-model-%E5%92%8C-v-show-%EF%BC%8CVue-%E4%B9%9F%E5%85%81%E8%AE%B8%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E3%80%82%E5%9C%A8-Vue2-0-%E4%B8%AD%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E5%BD%A2%E5%BC%8F%E6%98%AF%E7%BB%84%E4%BB%B6%E3%80%82%E7%84%B6%E8%80%8C%EF%BC%8C%E6%9C%89%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BB%8D%E7%84%B6%E9%9C%80%E8%A6%81%E5%AF%B9%E6%99%AE%E9%80%9A-DOM-%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%BF%99%E6%97%B6%E5%80%99%E5%B0%B1%E4%BC%9A%E7%94%A8%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">26.1.</span> <span class="toc-text">vue除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%88%86%E4%B8%BA%EF%BC%9A%E5%AE%9A%E4%B9%89%EF%BC%8C%E6%B3%A8%E5%86%8C%E5%92%8C%E4%BD%BF%E7%94%A8%E4%B8%89%E6%AD%A5"><span class="toc-number">26.2.</span> <span class="toc-text">自定义指令分为：定义，注册和使用三步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%89%EF%BC%9F"><span class="toc-number">26.3.</span> <span class="toc-text">在项目中常用的有？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B7%A6%E8%BE%B9%E5%9B%BA%E5%AE%9A200px%E5%AE%BD%E5%BA%A6%EF%BC%8C%E5%8F%B3%E8%BE%B9%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E5%B8%83%E5%B1%80%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">如何实现一个左边固定200px宽度，右边自适应的布局？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EMVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">关于MVVM设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Evuex%E7%8A%B6%E6%80%81%E5%85%B1%E4%BA%AB%E6%A1%86%E6%9E%B6"><span class="toc-number">29.</span> <span class="toc-text">关于vuex状态共享框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E6%A7%BD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B7%E5%90%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">什么是插槽？什么是具名插槽？什么是作用域插槽？什么是具名作用域插槽？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJS%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">什么是JS的作用域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">JS中数组的常用方法有哪些，分别有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%96%E5%87%BA%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">33.</span> <span class="toc-text">如何取出对象中所有的属性，举例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EObject-defineProperty"><span class="toc-number">34.</span> <span class="toc-text">关于Object.defineProperty()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%A6%82%E4%BD%95%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">vue如何全局注册一个组件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">webpack了解吗？有什么作用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFwebpack"><span class="toc-number">36.1.</span> <span class="toc-text">1、什么是webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Webpack%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">36.2.</span> <span class="toc-text">2、Webpack的优点是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">浏览器渲染过程中什么是重绘和回流？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-number">37.1.</span> <span class="toc-text">渲染过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81"><span class="toc-number">37.2.</span> <span class="toc-text">回流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%9B%9E%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">37.2.1.</span> <span class="toc-text">执行回流的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98"><span class="toc-number">37.3.</span> <span class="toc-text">重绘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%8E%BB%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%E5%91%A2"><span class="toc-number">37.4.</span> <span class="toc-text">怎么去减少回流和重绘呢</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">如何封装axios请求？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">39.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">40.</span> <span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E9%83%BD%E5%B0%81%E8%A3%85%E8%BF%87%E5%93%AA%E4%BA%9B%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6%EF%BC%9F%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">41.</span> <span class="toc-text">你都封装过哪些公共组件？举个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%B8%BAvue%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">你为vue项目做过哪些性能优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%92%8Chttps%E5%8D%8F%E8%AE%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%99%A4%E4%BA%86%E8%BF%99%E4%B8%A4%E4%B8%AA%EF%BC%8C%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE%E5%90%97%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">http和https协议有什么区别？除了这两个，还有其他协议吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive-%E7%BB%84%E4%BB%B6%E7%BC%93%E4%BB%8E"><span class="toc-number">44.</span> <span class="toc-text">keep-alive-组件缓从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%88%B6%E5%AD%90%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC"><span class="toc-number">45.</span> <span class="toc-text">vue父子之间的传值?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#canvas"><span class="toc-number">46.</span> <span class="toc-text">canvas</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0vue%E7%AD%89%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">47.</span> <span class="toc-text">简述vue等单页面应用及优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-%E5%88%87%E6%8D%A2%E9%A1%B5%E9%9D%A2%E5%BF%AB%EF%BC%8C%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E5%A5%BD"><span class="toc-number">47.0.1.</span> <span class="toc-text">优点 :切换页面快，用户体验好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A%E9%A6%96%E6%AC%A1%E5%8A%A0%E8%BD%BD%E8%BE%83%E6%85%A2%EF%BC%8CSEO%E4%BC%98%E5%8C%96%E5%B7%AE"><span class="toc-number">47.0.2.</span> <span class="toc-text">缺点：首次加载较慢，SEO优化差</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9Fdom%E5%92%8C%E7%9C%9F%E5%AE%9E%E7%9A%84dom%E5%9C%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%93%AA%E4%B8%AA%E5%9C%B0%E6%96%B9"><span class="toc-number">48.</span> <span class="toc-text">虚拟dom和真实的dom在生命周期的哪个地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">49.</span> <span class="toc-text">vue生命周期中父子组件的渲染顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%AD%E6%80%8E%E4%B9%88%E5%8E%BB%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">50.</span> <span class="toc-text">vue中怎么去监听数据的变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jquery%E5%92%8Cvue%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%A1%86%E6%9E%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">51.</span> <span class="toc-text">jquery和vue这两个框架有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch%E5%92%8Ccomputed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">52.</span> <span class="toc-text">watch和computed的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">53.</span> <span class="toc-text">为什么组件中的data是个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E8%BF%99%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">54.</span> <span class="toc-text">路由的两种路由模式，说一下你对这两种路由的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">55.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%89%8D%E5%8F%B0%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2404%E9%97%AE%E9%A2%98"><span class="toc-number">56.</span> <span class="toc-text">如何解决前台刷新页面404问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85%E4%B8%8A%E7%BA%BF%E7%9A%84%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">你们的项目是如何进行打包上线的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96vue%E7%9A%84%E5%8E%9F%E7%94%9F-DOM"><span class="toc-number">58.</span> <span class="toc-text">获取vue的原生 DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack%E7%9A%84%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">webpack的常见配置都有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C%E7%BE%8E%E5%B7%A5%E6%B2%9F%E9%80%9A%E4%BA%A4%E6%B5%81%E7%9A%84"><span class="toc-number">60.</span> <span class="toc-text">你们是如何和美工沟通交流的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0excel%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">如何实现excel文件的导入和导出？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3vue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86%E6%88%96%E8%80%85%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">62.</span> <span class="toc-text">怎么理解vue响应式数据的原理或者是双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-for-%E5%92%8Cv-if%E9%82%A3%E4%B8%AA%E5%85%88%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">v-for 和v-if那个先执行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff%E7%AE%97%E6%B3%95"><span class="toc-number">64.</span> <span class="toc-text">diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">65.</span> <span class="toc-text">路由传参的方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AF%BC%E8%88%AA%E5%92%8C%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">66.</span> <span class="toc-text">声明式导航和编程式导航的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AF%BC%E8%88%AA%E6%98%AF%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E5%88%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%8C%E6%AF%94%E5%A6%82a%E9%93%BE%E6%8E%A5"><span class="toc-number">66.1.</span> <span class="toc-text">1.声明式导航是直接渲染到页面的，比如a链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E5%88%99%E6%98%AF%E7%94%A8%E5%9C%A8js%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91%E5%90%8E%E9%9C%80%E8%A6%81%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%EF%BC%8C%E6%AF%94%E5%A6%82%E7%82%B9%E5%87%BBbutton%E6%8C%89%E9%92%AE%E8%B7%B3%E8%BD%AC"><span class="toc-number">66.2.</span> <span class="toc-text">2.编程式导航则是用在js处理逻辑后需要页面跳转，比如点击button按钮跳转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">67.</span> <span class="toc-text">vue全局注册一个插件的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E7%94%A8vue-use-%E5%B8%B8%E7%94%A8%E6%9D%A5%E6%B3%A8%E5%86%8C%E7%94%9F%E6%80%81%E7%B1%BB%E7%9A%84%E6%8F%92%E4%BB%B6-%E6%AF%94%E5%A6%82-vant-%EF%BC%8Celement-ui-%EF%BC%8C-router%EF%BC%8Cvuex"><span class="toc-number">67.1.</span> <span class="toc-text">采用vue.use 常用来注册生态类的插件  比如 vant ，element-ui ， router，vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E7%9A%84%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C-%EF%BC%9A-%E5%8F%AF%E4%BB%A5%E6%8C%82%E8%BD%BD%E5%88%B0vue%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8A%E9%9D%A2-%E6%AF%94%E5%A6%82-%EF%BC%9AVue-protype-http-x3D-axios%EF%BC%8C%E8%BF%98%E6%9C%89echacts-%E4%B9%9F%E4%B8%80%E6%A0%B7"><span class="toc-number">67.2.</span> <span class="toc-text">插件的全局注册 ： 可以挂载到vue的原型上面 比如 ：Vue.protype.$http &#x3D; axios，还有echacts  也一样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mixin-%E6%B7%B7%E5%85%A5"><span class="toc-number">67.3.</span> <span class="toc-text">mixin 混入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">68.</span> <span class="toc-text">单点登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8scss"><span class="toc-number">69.</span> <span class="toc-text">为什么使用scss</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%98%93%E7%BB%B4%E6%8A%A4%EF%BC%8C%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E5%AE%9A%E5%88%B6"><span class="toc-number">69.1.</span> <span class="toc-text">1.易维护，更方便的定制,</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8E%E7%BC%96%E7%A8%8B%E4%BA%BA%E5%91%98%E7%9A%84%E5%8F%8B%E5%A5%BD"><span class="toc-number">69.2.</span> <span class="toc-text">2.对于编程人员的友好,</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%88%E7%8E%87%E7%9A%84%E6%8F%90%E5%8D%87"><span class="toc-number">69.3.</span> <span class="toc-text">3.效率的提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">70.</span> <span class="toc-text">75.虚拟dom的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">70.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">70.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">71.</span> <span class="toc-text">for  in  和 for  of  的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%B8%AD0-1-0-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E0-3"><span class="toc-number">72.</span> <span class="toc-text">JS中0.1+0.2为什么不等于0.3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A80-1%E4%B8%8E-0-2-%E7%9B%B8%E5%8A%A0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BC%9A%E5%85%88%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%8C0-1%E4%B8%8E0-2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%BE%E6%95%B0%E4%BC%9A%E5%8F%91%E7%94%9F%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%9B%E8%A1%8C%E5%AF%B9%E9%98%B6%E8%BF%90%E7%AE%97%EF%BC%8Cjs%E5%BC%95%E6%93%8E%E5%AF%B9%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%9B%E8%A1%8C%E6%88%AA%E6%96%AD%EF%BC%8C%E6%89%80%E4%BB%A5%E9%80%A0%E6%88%90%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%EF%BC%9B"><span class="toc-number">72.1.</span> <span class="toc-text">在0.1与 0.2 相加的时候，会先转换为二进制，0.1与0.2转换为二进制的时候尾数会发生无限循环，然后进行对阶运算，js引擎对二进制进行截断，所以造成精度丢失；</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-apply-bind%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">73.</span> <span class="toc-text">call ,apply ,bind的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">73.1.</span> <span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">73.2.</span> <span class="toc-text">不同点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">74.</span> <span class="toc-text">闭包的理解及使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#less%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">75.</span> <span class="toc-text">less的使用方式及优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9elment-ui%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%BC%8F%EF%BC%9F"><span class="toc-number">76.</span> <span class="toc-text">如何修改elment-ui组件的样式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B0%E5%BB%BA%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E8%A1%A8"><span class="toc-number">76.1.</span> <span class="toc-text">1.新建全局样式表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8%E5%BD%93%E5%89%8Dvue%E9%A1%B5%E9%9D%A2%E4%B8%8B%E6%96%B0%E5%BB%BAstyle%E6%A0%87%E7%AD%BE"><span class="toc-number">76.2.</span> <span class="toc-text">2.在当前vue页面下新建style标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-x2F-deep-x2F-%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F"><span class="toc-number">76.3.</span> <span class="toc-text">3.使用&#x2F;deep&#x2F;进行深度修改样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%9A%E8%BF%87%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F-%E6%88%96%E8%80%85-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F"><span class="toc-number">76.4.</span> <span class="toc-text">4.通过内联样式 或者 绑定样式覆盖默认样式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">77.</span> <span class="toc-text">ajax的执行机制？</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="zhixiong"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">zhixiong</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">6</span>
        <span class="name">文章</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d3d3poaXhpb25n" title="https:&#x2F;&#x2F;github.com&#x2F;wwwzhixiong"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9oaXhpbmdfeg==" title="https:&#x2F;&#x2F;twitter.com&#x2F;hixing_z"><i class="ic i-twitter"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTEyODI3NzA2Ng==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;128277066"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vdS82MDg0NDg1Mzg1" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6084485385"><i class="ic i-weibo"></i></span>
      <span class="exturl item instagram" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL21veXVzaGkuYWE=" title="https:&#x2F;&#x2F;instagram.com&#x2F;moyushi.aa"><i class="ic i-instagram"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/09/15/%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9FDOM/" title="关于虚拟DOM">关于虚拟DOM</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2020/10/01/makedown%E8%AF%AD%E6%B3%95/" title="MakeDown语法&#39;">MakeDown语法'</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/09/16/%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/" title="数组的一些方法">数组的一些方法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/09/13/%E5%85%B3%E4%BA%8Epromise/" title="关于promise">关于promise</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/09/18/%E9%99%8B%E5%AE%A4%E9%93%AD/" title="陋室铭————刘禹锡">陋室铭————刘禹锡</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/12/01/2022%E5%89%8D%E7%AB%AF%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/" title="2022前端高频面试题">2022前端高频面试题</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhixiong @ Mondy</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">46k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">42 分钟</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/12/01/2022前端高频面试题/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
